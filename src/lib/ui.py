import os  # TODO: replace use by pathlib?
import sys
import tempfile
from pathlib import Path

import numpy as np
import pandas as pd
from PyQt5 import QtCore, QtGui, QtWidgets, sip

# pandas 3.0 changed the default string dtype to Arrow-backed string[pyarrow],
# which rejects assignment of non-string values (int, float, etc.).
# The project DataFrame mixes strings, ints and floats in the same CSV-loaded
# DataFrame, so we opt back into the legacy object-dtype string behaviour.
pd.options.future.infer_string = False

# Matplotlib slowdown fix for frozen Windows builds: redirect config dir to temp.
# Must be set before matplotlib is imported so it sees the override on first init.
if getattr(sys, "frozen", False):
    os.environ.setdefault(
        "MPLCONFIGDIR", os.path.join(tempfile.gettempdir(), "matplotlib")
    )

# TODO: kick these out to ui_plot.py
from matplotlib import use as matplotlib_use
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure

matplotlib_use("Qt5Agg")

import importlib  # for reloading modules
import json  # for saving and loading dicts as strings
import logging
import pickle  # for saving and loading dicts
import re  # regular expressions
import socket  # getting computer name and localdomain for df_project['host'] (not reported in talkback)
import time  # counting time for functions

# used by talkback
import uuid  # generating unique talkback ID
from datetime import datetime  # used in project name defaults

import analysis_v2 as analysis

# brainwash files
import parse

# read and write
import toml  # for reading pyproject.toml
import ui_data_frames
import ui_designer  # Import the Designer-generated UI code
import ui_groups
import ui_plot
import ui_project
import ui_state_classes
import ui_sweep_ops
import yaml  # used by talkback
from ui_project import df_projectTemplate

"""
####################################################################
#                    Table of Contents                             #
####################################################################

    Imports + Debug Probe
    Globals
        Config          (class for configuration settings)
        config          (singleton instance of Config)
        uistate         (singleton, UIstate for UI state management)
        uiplot          (singleton, UIplot for plotting state)
    Custom Sub-Classes
        TableModel      (custom model for table data)
        FileTreeSelectorModel (model for file tree selection)
        FileTreeSelectorDialog (dialog for file tree selection)
        MplCanvas       (Matplotlib canvas for plotting)
        CustomCheckBox  (custom checkbox widget)
        ProgressBarManager (manages progress bar updates)
        ParseDataThread (thread for parsing data)
        graphPreloadThread (thread for preloading graph data)
    Qt Designer Output
        Ui_MainWindow   (do not touch — generated by pyuic)
        Ui_Dialog       (do not touch — generated by pyuic)
    Popups / Dialogs
        InputDialogPopup (popup for user input)
        ConfirmDialog   (dialog for confirmation)
        confirm         (helper function for confirmation dialogs)
    Misc Widget Sub-Classes
        TableProjSub    (subclass for project table widget)
        Filetreesub     (subclass for file tree widget)
    Mixin Wiring        (injects singletons into mixin modules)
    Main Class (UIsub)  (composes Ui_MainWindow + all mixins)
        Selection Changers (methods for handling UI selections)
        UI Helpers         (freeze/thaw, darkmode, zoom, splitter, toolbar)
        UIsub Inits        (bootstrap → loadProject live in ProjectMixin)
        Triggers           (menu / button callbacks)
        Data Editing       (methods for editing data)
        Table Helpers      (df_p, df_t, tableProj, tableStim)
        Graph Interface    (methods for graph interactions)
        Mouseover + Click-and-Drag + Zoom Functions (UI interactions)
        pyqtSlot Decorators (decorators for Qt slots)
    Root Functions
        get_signals     (function to retrieve signals)
    Main Guard          (entry point for the application)
"""

logger = logging.getLogger(__name__)
logger.debug("ui.py: os.getcwd(): %s", os.getcwd())

####################################################################
#                             Globals                              #
####################################################################


class Config:
    def __init__(self):
        self.dev_mode = os.getenv("BRAINWASH_DEBUG", "0") == "1"  # Respect --debug flag
        print(
            "\n" * 3
            + f"{'Development' if self.dev_mode else 'Deploy'} mode - {time.strftime('%H:%M:%S')}"
        )

        clear = False  # Clear all caches and temporary files at launch
        self.clear_project_folder = (
            clear  # Remove current project folder (datafiles) at launch
        )
        self.clear_cache = clear
        self.clear_timepoints = clear
        self.force_cfg_reset = clear

        self.transient = False  # Block persisting of files

        self.verbose = self.dev_mode  # Now tied to --debug
        self.talkback = not self.dev_mode
        self.hide_experimental = not self.dev_mode
        self.track_widget_focus = False
        self.terminal_space = (
            372 if self.dev_mode else 100
        )  # pixels reserved for viewing prints

        # get project_name and version number from pyproject.toml
        #
        # Search order (most-specific first):
        #   1. Frozen build: the exe lives in build/exe.*/ and we copy
        #      pyproject.toml to lib/pyproject.toml next to it, so look
        #      relative to sys.executable first.
        #   2. Development: relative paths from cwd (src/ or repo root).
        #   3. Fallback: walk every entry in sys.path (AppImage, editable
        #      installs, unusual working directories).
        def _find_file(filename: str) -> Path | None:
            # 1. Relative to the executable (frozen) or this source file (dev)
            anchors: list[Path] = []
            if getattr(sys, "frozen", False):
                anchors.append(Path(sys.executable).parent)
            anchors.append(Path(__file__).parent)  # src/lib/
            anchors.append(Path(__file__).parent.parent)  # src/
            anchors.append(Path(__file__).parent.parent.parent)  # repo root

            for anchor in anchors:
                for rel in ["lib/" + filename, filename]:
                    candidate = anchor / rel
                    if candidate.is_file():
                        return candidate

            # 2. sys.path fallback (AppImage / unusual layouts)
            for entry in sys.path:
                candidate = Path(entry) / filename
                if candidate.is_file():
                    return candidate

            return None

        toml_path = _find_file("pyproject.toml")
        if toml_path is None:
            raise FileNotFoundError(
                "pyproject.toml not found. Searched relative to executable, "
                "source file, and all sys.path entries."
            )
        logger.debug("Config: loading pyproject.toml from %s", toml_path)

        bwcfg_path = _find_file("bw_cfg.yaml")
        logger.debug("Config: bw_cfg.yaml %s", bwcfg_path or "not found")

        pyproject = toml.load(toml_path)
        self.bw_cfg_yaml = str(bwcfg_path) if bwcfg_path is not None else None
        self.program_name = pyproject["project"]["name"]
        self.version = pyproject["project"]["version"]


config = Config()
uistate = ui_state_classes.UIstate()  # global variable for storing state of UI
importlib.reload(ui_plot)
uiplot = ui_plot.UIplot(uistate)


####################################################################
#                       Custom sub-classes                         #
####################################################################


class TableModel(QtCore.QAbstractTableModel):
    def __init__(self, data=None):
        super(TableModel, self).__init__()
        self._data = data

    def data(self, index, role=None):  # dataCell
        if role is None:
            value = self._data.iloc[index.row(), index.column()]
            return value
        if role == QtCore.Qt.DisplayRole:
            value = self._data.iloc[index.row(), index.column()]
            return str(value)

    def dataRow(self, index, role=None):
        # TODO: return entire selected row
        if role is None:
            value = self._data.iloc[index.row(), :]
            return value

    def rowCount(self, index):
        return self._data.shape[0]

    def columnCount(self, index):
        return self._data.shape[1]

    def headerData(self, section, orientation, role):
        # section is the index of the column/row.
        if role == QtCore.Qt.DisplayRole:
            if orientation == QtCore.Qt.Horizontal:
                return str(self._data.columns[section])

            if orientation == QtCore.Qt.Vertical:
                return str(self._data.index[section])

    def setData(self, data: pd.DataFrame = None):
        self.beginResetModel()
        if data is None:
            self._data = pd.DataFrame()
        elif isinstance(data, pd.DataFrame):
            self._data = data
        else:
            return False
        self.endResetModel()
        return True

    def sort(self, column, order):
        try:
            self.layoutAboutToBeChanged.emit()
            self._data = self._data.sort_values(
                self._data.columns[column], ascending=order == QtCore.Qt.AscendingOrder
            )
            self.layoutChanged.emit()
        except Exception as e:
            print(f"Error sorting table: {e}")


class FileTreeSelectorModel(
    QtWidgets.QFileSystemModel
):  # Paired with a FileTreeSelectorView
    paths_selected = QtCore.pyqtSignal(list)

    def __init__(self, parent=None, root_path="."):
        QtWidgets.QFileSystemModel.__init__(self, None)
        self.root_path = root_path
        self.checks = {}
        self.nodestack = []
        self.parent_index = self.setRootPath(self.root_path)
        self.root_index = self.index(self.root_path)

        self.setFilter(QtCore.QDir.AllEntries | QtCore.QDir.NoDotAndDotDot)
        self.sort(0, QtCore.Qt.SortOrder.AscendingOrder)
        self.directoryLoaded.connect(self._loaded)

    def _loaded(self, path):
        logger.debug(
            "_loaded %s rowCount=%s", self.root_path, self.rowCount(self.parent_index)
        )
        print("_loaded", self.root_path, self.rowCount(self.parent_index))

    def data(self, index, role=QtCore.Qt.DisplayRole):
        if role != QtCore.Qt.CheckStateRole:
            return QtWidgets.QFileSystemModel.data(self, index, role)
        else:
            if index.column() == 0:
                return self.checkState(index)

    def flags(self, index):
        return (
            QtWidgets.QFileSystemModel.flags(self, index)
            | QtCore.Qt.ItemIsUserCheckable
        )

    def checkState(self, index):
        if index in self.checks:
            return self.checks[index]
        else:
            return QtCore.Qt.Unchecked

    def getCheckedPaths(self):
        paths = []
        for k, v in self.checks.items():
            if v == 2:  # Checked
                paths.append(format(self.filePath(k)))
        self.paths_selected.emit(paths)

    def setData(self, index, value, role):
        if role == QtCore.Qt.CheckStateRole and index.column() == 0:
            self.checks[index] = value
            logger.debug("setData(): %s", value)
            print("setData(): {}".format(value))
            return True
        return QtWidgets.QFileSystemModel.setData(self, index, value, role)

    def traverseDirectory(self, parentindex, callback=None):
        if self.verbose:
            print("traverseDirectory():")
        callback(parentindex)
        if self.hasChildren(parentindex):
            path = self.filePath(parentindex)
            it = QtCore.QDirIterator(path, self.filter() | QtCore.QDir.NoDotAndDotDot)
            while it.hasNext():
                childIndex = self.index(it.next())
                self.traverseDirectory(childIndex, callback=callback)
        else:
            print("no children")

    def printIndex(self, index):
        print("model printIndex(): {}".format(self.filePath(index)))


class FileTreeSelectorDialog(QtWidgets.QWidget):
    def __init__(self, parent=None, root_path="."):
        super().__init__(parent)

    def delayedInitForRootPath(self, root_path):
        self.root_path = str(root_path)

        # Model
        self.model = FileTreeSelectorModel(root_path=self.root_path)
        # self.model          = QtWidgets.QFileSystemModel()

        # view
        self.view = QtWidgets.QTreeView()

        self.view.setObjectName("treeView_fileTreeSelector")
        self.view.setWindowTitle("Dir View")  # TODO:  Which title?
        self.view.setSortingEnabled(False)

        # Attach Model to View
        self.view.setModel(self.model)
        self.view.setRootIndex(self.model.parent_index)
        self.view.setAnimated(False)
        self.view.setIndentation(20)
        self.view.setColumnWidth(0, 250)
        self.view.setColumnWidth(1, 100)
        self.view.setColumnWidth(2, 50)
        self.view.setColumnHidden(3, True)

        # Misc
        self.node_stack = []

        # GUI
        windowlayout = QtWidgets.QVBoxLayout()
        windowlayout.addWidget(self.view)
        self.setLayout(windowlayout)

        # QtCore.QMetaObject.connectSlotsByName(self)

    @QtCore.pyqtSlot(QtCore.QModelIndex)
    def on_treeView_fileTreeSelector_clicked(self, index):
        self.model.getCheckedPaths()


class MplCanvas(FigureCanvasQTAgg):
    # graph window, setting parent to None to make it standalone
    def __init__(self, parent=None, width=5, height=4, dpi=100):
        fig = Figure(figsize=(width, height), dpi=dpi)
        self.axes = fig.add_subplot(111)
        super(MplCanvas, self).__init__(fig)
        self.setParent(parent)


class CustomCheckBox(QtWidgets.QCheckBox):
    # Custom checkbox to allow right-click to rename group
    rightClicked = QtCore.pyqtSignal(int)  # Define a new signal that carries an integer

    def __init__(self, group_ID, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.group_ID = group_ID  # int 1-9

    def mousePressEvent(self, event):
        if event.button() == QtCore.Qt.RightButton:
            self.rightClicked.emit(self.group_ID)
        else:
            super().mousePressEvent(event)


class ProgressBarManager:
    def __init__(self, progressBar, total):
        self.progressBar = progressBar
        self.total = total
        print(f"*** Progressbar start: {self.progressBar.value()}")
        print(f"*** Progressbar total: {total}")

    def __enter__(self):
        self.progressBar.setValue(0)
        self.progressBar.setFormat("")
        self.progressBar.setVisible(True)
        return self

    def __exit__(self, type, value, traceback):
        self.total = 0
        self.progressBar.setFormat("")
        self.progressBar.setVisible(False)

    def update(self, i, task_description):
        if self.total == 0:
            print(
                "*** ERROR: Update request for non-existent task."
            )  # TODO: This scenario should have been prevented by the callers - why isn't it? Related to __exit__ setting it to 0?
            return
        percentage = int((i) * 100 / self.total)
        self.progressBar.setValue(percentage)
        self.progressBar.setFormat(
            f"{task_description} {i + 1} / {self.total}:   %p% complete"
        )


class ParseDataThread(QtCore.QThread):
    progress = QtCore.pyqtSignal(int)
    finished = QtCore.pyqtSignal()  # custom signal, decoupled from QThread.finished

    def __init__(self, df_p_to_update, dict_folders, uisub):
        super().__init__()
        self.df_p_to_update = df_p_to_update
        self.dict_folders = dict_folders
        self.uisub = uisub
        self.rows = []
        self.total = len(df_p_to_update)

    def run(self):
        """Parse data from files, persist them as bw parquet:s, and update df_p"""
        try:
            for i, (_, df_proj_row) in enumerate(self.df_p_to_update.iterrows()):
                recording_name = df_proj_row["recording_name"]
                source_path = df_proj_row["path"]
                self.progress.emit(i)
                split_odd_even = uistate.checkBox.get("splitOddEven", False)
                split_at_time = uistate.lineEdit.get("split_at_time", 0) or None
                dict_dfs_raw = parse.source2dfs(
                    source=source_path,
                    gain=uistate.lineEdit["import_gain"],
                    split_odd_even=split_odd_even,
                    split_at_time=split_at_time,
                )
                if not dict_dfs_raw:
                    print(f"Failed to read source file at: {source_path}")
                    continue
                # Keys are either plain channel ints {ch: df} or split tuples {(ch, label): df}.
                # Normalise both into recording_name:df, appending _ch / _label suffixes as needed.
                first_key = next(iter(dict_dfs_raw))
                split_keys = isinstance(first_key, tuple)
                n_channels = len(
                    {k[0] for k in dict_dfs_raw} if split_keys else dict_dfs_raw
                )
                dict_name_df = {}
                for key, df in dict_dfs_raw.items():
                    if split_keys:
                        channel, label = key
                        ch_suffix = f"_ch{channel}" if n_channels > 1 else ""
                        dict_name_df[f"{recording_name}{ch_suffix}_{label}"] = df
                    else:
                        channel = key
                        ch_suffix = f"_ch{channel}" if n_channels > 1 else ""
                        dict_name_df[f"{recording_name}{ch_suffix}"] = df
                for rec, df_raw in dict_name_df.items():
                    logger.debug("ParseDataThread: %s", rec)
                    print(f"ParseDataThread: {rec}")
                    df_proj_new_row = self.uisub.create_recording(
                        df_proj_row, rec, df_raw
                    )
                    self.rows.append(df_proj_new_row)
        except Exception as e:
            import traceback

            logger.exception(
                f"ParseDataThread.run: EXCEPTION: {e}\n{traceback.format_exc()}"
            )
        finally:
            self.finished.emit()


class graphPreloadThread(QtCore.QThread):
    finished = QtCore.pyqtSignal()
    progress = QtCore.pyqtSignal(int)

    def __init__(self, uistate, uiplot, uisub):
        super().__init__()
        self.rows = []
        self.uistate = uistate
        self.uiplot = uiplot
        self.uisub = uisub
        self.df_p = self.uisub.get_df_project()
        self.i = 0

    def run(self):
        try:
            print(
                f"graphPreloadThread.run: entered, {len(self.uistate.list_idx_recs2preload)} recordings"
            )
            df_p = self.df_p.loc[self.uistate.list_idx_recs2preload]
            self.uistate.list_idx_recs2preload = []
            self.i = 0
            for i, p_row in df_p.iterrows():
                print(f"graphPreloadThread.run: processing {p_row['recording_name']}")
                print("graphPreloadThread.run: calling get_dft")
                dft = self.uisub.get_dft(row=p_row)
                print(f"graphPreloadThread.run: get_dft returned {type(dft)}")
                if dft is None:
                    print(
                        f"graphPreloadThread.run: dft is None for {p_row['recording_name']} (no stims detected), skipping"
                    )
                    continue
                print("graphPreloadThread.run: calling get_dfmean")
                dfmean = self.uisub.get_dfmean(row=p_row)
                print("graphPreloadThread.run: calling get_dffilter")
                _ = self.uisub.get_dffilter(row=p_row)
                print("graphPreloadThread.run: calling get_dfoutput")
                if self.uistate.checkBox["paired_stims"]:
                    dfoutput = self.uisub.get_dfdiff(row=p_row)
                else:
                    dfoutput = self.uisub.get_dfoutput(row=p_row)
                print(f"graphPreloadThread.run: get_dfoutput returned {type(dfoutput)}")
                if dfoutput is None:
                    print(
                        "graphPreloadThread.run: dfoutput is None, skipping this recording"
                    )
                    continue
                print(
                    f"graphPreloadThread, {p_row['recording_name']} calls uiplot.addRow() dfoutput columns: {dfoutput.columns}"
                )
                self.uiplot.addRow(
                    p_row=p_row.to_dict(), dft=dft, dfmean=dfmean, dfoutput=dfoutput
                )
                self.progress.emit(i)
                self.i += 1
                print(f"Preloaded {p_row['recording_name']}")
        except Exception as e:
            import traceback

            logger.exception(
                f"graphPreloadThread.run: EXCEPTION: {e}\n{traceback.format_exc()}"
            )
        finally:
            self.finished.emit()


################################################################
#        Dialog and table classes                              #
################################################################


class Ui_Dialog(QtWidgets.QWidget):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(1105, 525)
        self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
        self.buttonBox.setGeometry(QtCore.QRect(930, 480, 161, 32))
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(
            QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Ok
        )
        self.buttonBox.setObjectName("buttonBox")
        self.widget = FileTreeSelectorDialog(Dialog)
        self.widget.setGeometry(QtCore.QRect(10, 10, 451, 501))
        self.widget.setObjectName("widget")
        self.tableView = QtWidgets.QTableView(Dialog)
        self.tableView.setGeometry(QtCore.QRect(570, 10, 521, 461))
        self.tableView.setObjectName("tableView")

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept)
        self.buttonBox.rejected.connect(Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))


class InputDialogPopup(QtWidgets.QDialog):
    def __init__(self):
        super().__init__()
        self.input = QtWidgets.QLineEdit(self)
        self.buttonBox = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            self,
        )
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.input)
        layout.addWidget(self.buttonBox)

    def showInputDialog(self, title, query):
        self.setWindowTitle(title)
        self.input.setPlaceholderText(query)
        self.setFixedSize(300, 150)  # Set the fixed width and height of the dialog
        result = self.exec_()
        text = self.input.text()
        if result == QtWidgets.QDialog.Accepted:
            print(f"You entered: {text}")
            return text


class ConfirmDialog(QtWidgets.QDialog):
    """Confirmation dialog with OK and Cancel buttons.
    Usage:
        dlg = ConfirmDialog(title='Confirm', message='Are you sure?')
        ok = dlg.showConfirmDialog()
        # ok is True when user pressed OK, False otherwise
    """

    def __init__(self, title: str = "Confirm", message: str = "Are you sure?"):
        super().__init__()
        self.setWindowTitle(title)
        self.label = QtWidgets.QLabel(message, self)
        self.buttonBox = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            self,
        )
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.label)
        layout.addWidget(self.buttonBox)

    def showConfirmDialog(
        self, title: str | None = None, message: str | None = None
    ) -> bool:
        """Show the dialog modally. Returns True for OK, False for Cancel."""
        if title is not None:
            self.setWindowTitle(title)
        if message is not None:
            self.label.setText(message)
        result = self.exec_()
        return result == QtWidgets.QDialog.Accepted


def confirm(title: str = "Confirm", message: str = "Are you sure?") -> bool:
    """Convenience function: show confirmation dialog and return bool result."""
    dlg = ConfirmDialog(title=title, message=message)
    return dlg.showConfirmDialog()


class TableProjSub(QtWidgets.QTableView):
    # TODO: This class does the weirdest things to events; shifting event numbers around in non-standard ways and refuses to notice drops - but drag-into works. Why?
    def __init__(self, parent=None):
        super().__init__()
        self.parent = parent
        self.setAcceptDrops(True)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            file_urls = [url.toLocalFile() for url in event.mimeData().urls()]
            print("Files dropped:", file_urls)
            # Handle the dropped files here
            dfAdd = df_projectTemplate()
            dfAdd["path"] = (
                file_urls  # needs to be first, as it sets the number of rows
            )
            dfAdd["host"] = str(self.parent.fqdn)
            dfAdd["filter"] = "voltage"
            # NTH: more intelligent default naming; lowest level unique name?
            # For now, use name + lowest level folder
            names = []
            duplicates = []  # remove these from dfAdd
            for i in file_urls:
                # check if file is already in df_project
                if i in self.parent.df_project["path"].values:
                    print(f"File {i} already in df_project")
                    duplicates.append(i)
                else:
                    names.append(
                        os.path.basename(os.path.dirname(i)) + "_" + os.path.basename(i)
                    )
            if not names:
                print("No new files to add.")
                return
            dfAdd = dfAdd.drop(dfAdd[dfAdd["path"].isin(duplicates)].index)
            dfAdd["recording_name"] = names
            self.parent.addData(dfAdd)
            event.acceptProposedAction()
        else:
            event.ignore()


class Filetreesub(Ui_Dialog):
    def __init__(self, dialog, parent=None, folder="."):
        super(Filetreesub, self).__init__()
        self.setupUi(dialog)
        self.parent = parent
        logger.debug("Filetreesub init")
        print(" - Filetreesub init")

        self.ftree = self.widget
        # set root_path for file tree model
        self.ftree.delayedInitForRootPath(folder)
        # self.ftree.model.parent_index   = self.ftree.model.setRootPath(projects_folder)
        # self.ftree.model.root_index     = self.ftree.model.index(projects_folder)

        # Dataframe to add
        self.names = []
        self.dfAdd = df_projectTemplate()

        self.buttonBoxAddGroup = QtWidgets.QDialogButtonBox(dialog)
        self.buttonBoxAddGroup.setGeometry(QtCore.QRect(470, 20, 91, 491))
        self.buttonBoxAddGroup.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.buttonBoxAddGroup.setOrientation(QtCore.Qt.Vertical)
        self.buttonBoxAddGroup.setStandardButtons(QtWidgets.QDialogButtonBox.NoButton)
        self.buttonBoxAddGroup.setObjectName("buttonBoxAddGroup")

        self.ftree.view.clicked.connect(
            self.widget.on_treeView_fileTreeSelector_clicked
        )
        self.ftree.model.paths_selected.connect(self.pathsSelectedUpdateTable)
        self.buttonBox.accepted.connect(self.addDf)

        self.tablemodel = TableModel(self.dfAdd)
        self.tableView.setModel(self.tablemodel)

    def addDf(self):
        self.parent.slotAddDfData(self.dfAdd)

    def pathsSelectedUpdateTable(self, paths):
        # TODO: Extract host and group
        dfAdd = df_projectTemplate()
        dfAdd["path"] = paths
        dfAdd["host"] = str(self.parent.fqdn)
        dfAdd["filter"] = "voltage"
        self.tablemodel.setData(dfAdd)
        # NTH: more intelligent default naming; lowest level unique name?
        # For now, use name + lowest level folder
        names = []
        for i in paths:
            names.append(
                os.path.basename(os.path.dirname(i)) + "_" + os.path.basename(i)
            )
        dfAdd["recording_name"] = names
        self.dfAdd = dfAdd
        # TODO: Add a loop that prevents duplicate names by adding a number until it becomes unique
        # format tableView
        header = self.tableView.horizontalHeader()
        self.tableView.setColumnHidden(0, True)  # host
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)  # path
        header.setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeToContents)  # name
        header.setSectionResizeMode(4, QtWidgets.QHeaderView.ResizeToContents)  # group
        self.tableView.update()


####################################################################
#                       Mixin wiring                               #
####################################################################


# ---------------------------------------------------------------------------
# Wire mixin modules to shared singletons.
# This must happen after all singletons (config, uistate, uiplot) and all
# widget classes (CustomCheckBox, InputDialogPopup, confirm) are defined,
# but before any UIsub instance is constructed.
# ---------------------------------------------------------------------------
ui_groups.uistate = uistate
ui_groups.config = config
ui_groups.uiplot = uiplot
ui_groups.CustomCheckBox = CustomCheckBox

ui_sweep_ops.uistate = uistate
ui_sweep_ops.config = config
ui_sweep_ops.uiplot = uiplot
ui_sweep_ops.confirm = confirm

ui_project.uistate = uistate
ui_project.config = config
ui_project.uiplot = uiplot
ui_project.InputDialogPopup = InputDialogPopup

ui_data_frames.uistate = uistate
ui_data_frames.config = config
ui_data_frames.uiplot = uiplot


####################################################################
#                    Main class (UIsub)                            #
####################################################################


# Composes Ui_MainWindow with all mixins.
class UIsub(
    ui_designer.Ui_mainWindow,
    ui_groups.GroupMixin,
    ui_sweep_ops.SweepOpsMixin,
    ui_project.ProjectMixin,
    ui_data_frames.DataFrameMixin,
):
    def __init__(self, mainwindow):
        logger.debug("UIsub __init__ started")
        super(UIsub, self).__init__()
        logger.debug("super().__init__() done, calling setupUi...")
        self.setupUi(mainwindow)  # as generated by QtDesigner - do not touch!
        logger.debug("setupUi done")
        logger.debug("UIsub init")
        print(" - UIsub init, verbose mode")

        # Custom UI initialization - non-QtDesigner-generated instructions
        self.pushButtonParse.setVisible(False)
        self.frameParseOptions.setVisible(False)
        self.progressBar.setVisible(False)
        self.progressBar.setValue(0)

        if config.hide_experimental:
            self.checkBox_show_all_events.setVisible(False)
            self.checkBox_output_per_stim.setVisible(False)
            self.checkBox_paired_stims.setVisible(False)
            self.checkBox_timepoints_per_stim.setVisible(False)
            self.pushButton_stim_assign_threshold.setVisible(False)
            self.pushButton_stim_detect.setVisible(False)
            self.label_stim_detection_threshold.setVisible(False)
            self.frameToolBin.setVisible(False)
            #            self.checkBox_bin.setVisible(False)
            self.pushButton_norm_range_set_all.setVisible(False)
            self.frameToolExport.setVisible(False)
            self.lineEdit_EPSP_amp_halfwidth.setVisible(False)
            self.lineEdit_volley_amp_halfwidth.setVisible(False)
            self.label_header_amp_halfwidth.setVisible(False)
            self.label_EPSP_amp_halfwidth.setVisible(False)
            self.label_volley_amp_halfwidth.setVisible(False)

        logger.debug("Pre-bootstrap")
        self.bootstrap(mainwindow)  # set up general UI
        logger.debug("bootstrap done, calling loadProject...")
        self.loadProject()  # load project data
        logger.debug("loadProject done")

    # Debugging tools

    def checkFocus(self):
        focused_widget = QtWidgets.QApplication.focusWidget()
        if focused_widget is not None:
            print(f"Focused Widget: {focused_widget.objectName()}")
        else:
            print("No widget has focus.")

    def find_widgets_with_top_left_coordinates(self, widget):
        print("trying child geometry")
        for child in widget.findChildren(QtWidgets.QWidget):
            # print(f"attribs: {dir(child.geometry())}")
            print(
                f"child.geometry(): {child.objectName()}, {child.geometry().topLeft()},  {child.mapTo(self.centralwidget, child.geometry().topLeft())}, {child.geometry().size()}"
            )

    ######################################################################
    #                     Selection changers                             #
    ######################################################################

    def tableProjSelectionChanged(self):
        if self.updating_tableProj:
            return
        self.usage("tableProjSelectionChanged")
        if QtWidgets.QApplication.mouseButtons() == QtCore.Qt.RightButton:
            self.tableProj.clearSelection()
        selected_indexes = self.tableProj.selectionModel().selectedRows()
        # build the list uistate.list_idx_select_recs with indices
        uistate.list_idx_select_recs = [index.row() for index in selected_indexes]
        # print(f" - rec_select: {uistate.list_idx_select_recs}")
        self.update_recs2plot()
        self.update_show()
        if uistate.df_recs2plot is None:
            print("No parsed recordings selected.")
            self.graphRefresh()
            return
        prow = self.get_prow()
        # if exactly one stim of one recording is selected, reference its data in uistate.df_rec_select_data, and timepoints in uistate.df_rec_select_time
        if (
            len(uistate.list_idx_select_recs) == 1
            and len(uistate.list_idx_select_stims) == 1
        ):
            uistate.df_rec_select_time = dft_for_format = self.get_dft(row=prow)
            uistate.df_rec_select_data = self.get_dffilter(prow)
            uistate.float_sweep_duration_max = prow["sweep_duration"]
            logger.debug(
                "One recording selected: index %s, stim index %s",
                uistate.list_idx_select_recs[0],
                uistate.list_idx_select_stims[0],
            )
            print(f"One recording selected: index {uistate.list_idx_select_recs[0]}")
            print(f"One stim selected: index {uistate.list_idx_select_stims[0]}")
        else:
            uistate.df_rec_select_data = None
            uistate.df_rec_select_time = None
            # store the selected prow with the highest sweep duration for layout formatting, so that the full x-axis is visible
            longest_sweep_prow = uistate.df_recs2plot.loc[
                uistate.df_recs2plot["sweep_duration"].idxmax()
            ]
            uistate.float_sweep_duration_max = longest_sweep_prow["sweep_duration"]
            dft_for_format = self.get_dft(row=longest_sweep_prow)

        if uistate.dict_rec_show and dft_for_format is not None:
            selected_stims = (
                self.tableStim.selectionModel().selectedRows()
            )  # save selection
            self.tableStimModel.setData(dft_for_format)
            model = self.tableStim.model()
            selection = QtCore.QItemSelection()
            for index in selected_stims:
                row_idx = index.row()
                index_start = model.index(row_idx, 0)  # Start of the row (first column)
                index_end = model.index(
                    row_idx, model.columnCount(QtCore.QModelIndex()) - 1
                )  # End of the row (last column)
                selection.select(index_start, index_end)
            self.tableStim.selectionModel().select(
                selection, QtCore.QItemSelectionModel.Select
            )
            self.formatTableStimLayout(dft=dft_for_format)
        elif dft_for_format is None:
            logger.debug(
                "tableProjSelectionChanged: dft_for_format is None (no stims detected), skipping stim table update"
            )
        self.zoomAuto()

        t0 = time.time()
        self.mouseoverUpdate()
        print(f" - - mouseoverUpdate: {round((time.time() - t0) * 1000)} ms")

    def stimSelectionChanged(self):
        self.usage("stimSelectionChanged")
        if QtWidgets.QApplication.mouseButtons() == QtCore.Qt.RightButton:
            self.tableStim.clearSelection()
        if uistate.mean_mouseover_stim_select is None:  # clicked table
            selected_indexes = self.tableStim.selectionModel().selectedRows()
        else:  # clicked graph
            row = uistate.mean_mouseover_stim_select - 1
            selected_indexes = [self.tableStimModel.index(row, 0)]
        uistate.mean_mouseover_stim_select = None
        # build the list uistate.list_idx_select_stims with indices
        uistate.list_idx_select_stims = [index.row() for index in selected_indexes]
        self.update_show()
        self.zoomAuto()
        self.mouseoverUpdate()

    def update_show(self, reset=False):
        aspects = [
            "EPSP_amp",
            "EPSP_slope",
            "volley_amp",
            "volley_slope",
            "volley_amp_mean",
            "volley_slope_mean",
        ]
        old_selection = uistate.dict_rec_show
        if uistate.df_recs2plot is None:
            reset = True
            new_selection = {}
        else:
            selected_ids = set(uistate.df_recs2plot["ID"])
            selected_stims = [
                stim + 1 for stim in uistate.list_idx_select_stims
            ]  # stim_select is 0-based (indices) - convert to stims
            print(
                f"update_show, selected_ids: {selected_ids}, selected_stims: {selected_stims}, reset: {reset}"
            )
            # remove non-selected recs and stims
            new_selection = {
                k: v
                for k, v in uistate.dict_rec_labels.items()
                if v["rec_ID"] in selected_ids
                and (v["stim"] in selected_stims or v["stim"] is None)
                and all(
                    uistate.checkBox[aspect] or v.get("aspect", "") != aspect
                    for aspect in aspects
                )
            }
            if not uistate.checkBox["norm_EPSP"]:
                filters = [" norm"]
            else:
                filters = [
                    " EPSP amp",
                    " EPSP slope",
                ]
            new_selection = {
                k: v
                for k, v in new_selection.items()
                if not any(k.endswith(f) for f in filters)
            }
        if reset:  # Hide all lines
            obsolete_lines = uistate.dict_rec_labels
        else:
            obsolete_lines = {
                k: v for k, v in old_selection.items() if k not in new_selection
            }
        for line_dict in obsolete_lines.values():
            line_dict["line"].set_visible(False)
        # Show what's now selected
        added_lines = {k: v for k, v in new_selection.items() if k not in old_selection}
        for line_dict in added_lines.values():
            line_dict["line"].set_visible(True)
        uistate.dict_rec_show = new_selection

        # group view
        if self.dd_groups is not None:
            reset_groups = False
            if uistate.dict_group_show == {}:
                reset_groups = True
            old_group_selection = uistate.dict_group_show.copy()
            # if any recs are selected, show only groups that contain selected recs
            if uistate.df_recs2plot is not None:
                selected_groups = {
                    group
                    for rec_ID in selected_ids
                    for group in self.get_groupsOfRec(rec_ID)
                }
                new_group_selection = {
                    k: v
                    for k, v in uistate.dict_group_labels.items()
                    if v["group_ID"] in selected_groups
                }
            else:
                new_group_selection = uistate.dict_group_labels.copy()
            new_group_selection = {
                k: v
                for k, v in new_group_selection.items()
                if all(
                    uistate.checkBox[aspect] or v.get("aspect", "") != aspect
                    for aspect in aspects
                )
            }
            if uistate.checkBox["norm_EPSP"]:
                filters = [" norm"]
            else:
                filters = [" mean"]
            new_group_selection = {
                k: v
                for k, v in new_group_selection.items()
                if any(k.endswith(f) for f in filters)
                and self.dd_groups[v["group_ID"]]["show"]
            }
            if reset_groups:  # Hide all lines
                obsolete_group_lines = uistate.dict_group_labels
            else:
                obsolete_group_lines = {
                    k: v
                    for k, v in old_group_selection.items()
                    if k not in new_group_selection
                }
            print(f"obsolete_group_lines: {obsolete_group_lines.keys()}")
            for k, line_dict in obsolete_group_lines.items():
                print(f"Obsolete group line key: {k}")
                line_dict["line"].set_visible(False)
                line_dict["fill"].set_visible(False)
            # Show what's now selected
            added_group_lines = {
                k: v
                for k, v in new_group_selection.items()
                if k not in old_group_selection
            }
            print(f"added_group_lines: {added_group_lines.keys()}")
            for k, line_dict in added_group_lines.items():
                print(f"Added group line key: {k}")
                line_dict["line"].set_visible(True)
                line_dict["fill"].set_visible(True)
            uistate.dict_group_show = new_group_selection

        # return
        # DEBUG block - for inquiring visibility of specific lines
        print(f"update_show: {len(uistate.dict_rec_show)}")
        if self.dd_groups is not None:
            for key, value in self.dd_groups.items():
                print(f"update_show: {key}, show:{value['show']}")
        for key, value in uistate.dict_rec_show.items():
            if key.endswith(" volley amp mean") or key.endswith(" volley slope mean"):
                print(f"update_show: {key}, show:{value['line'].get_visible()}")
                print(f" - ydata: {value['line'].get_ydata()}")

    ##################################################################
    #    WIP section: TODO: move to appropriate header               #
    ##################################################################

    def graphRefresh(self):
        self.usage("graphRefresh")
        uiplot.graphRefresh(self.dd_groups)

    def deleteFolder(self, dir_path):
        if os.path.exists(dir_path):
            for filename in os.listdir(dir_path):
                file_path = os.path.join(dir_path, filename)
                if os.path.isfile(file_path) or os.path.islink(file_path):
                    os.unlink(file_path)  # remove file or symlink
                elif os.path.isdir(file_path):
                    self.deleteFolder(file_path)  # recursively remove a subdirectory
            os.rmdir(dir_path)  # remove the directory itself

    def uiFreeze(self):  # Disable selection changes and checkboxes
        if uistate.frozen:
            return
        uistate.frozen = True
        self.tableProj.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        self.tableStim.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
        self.connectUIstate(disconnect=True)
        for key, _ in uistate.checkBox.items():
            checkBox = getattr(self, f"checkBox_{key}")
            checkBox.setEnabled(False)

    def uiThaw(self):  # Enable selection changes and checkboxes
        if not uistate.frozen:
            return
        self.tableProj.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.tableStim.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.connectUIstate()
        for key, _ in uistate.checkBox.items():
            checkBox = getattr(self, f"checkBox_{key}")
            checkBox.setEnabled(True)
        uistate.frozen = False

    def toggleHeatmap(self):
        uistate.showHeatmap = not uistate.showHeatmap
        print(f"Heatmap is {uistate.showHeatmap}")
        if not uistate.showHeatmap:
            uiplot.heatunmap()
            return
        t0 = time.time()
        d_group_ndf = {}
        list_l = []
        for key, sub_dict in self.dd_groups.items():
            if sub_dict["show"]:
                n = len(sub_dict["rec_IDs"])
                df = self.get_dfgroupmean(key)
                list_l.append(len(df))
                d_group_ndf[key] = [n, df]
        if len(d_group_ndf) == 2:
            if list_l[0] == list_l[1]:
                for key, ndf in d_group_ndf.items():
                    n = ndf[0]
                    df = ndf[1]
                    l = len(df)
                    list_l.append(l)
                    print(f"{key} - N: {n} - {l} sweeps")
                # perform test
                norm = uistate.checkBox["norm_EPSP"]
                amp = uistate.checkBox["EPSP_amp"]
                slope = uistate.checkBox["EPSP_slope"]
                df_ttest = analysis.ttest_df(
                    d_group_ndf, norm=norm, amp=amp, slope=slope
                )
                if not df_ttest.empty:
                    uiplot.heatmap(df_ttest)
                print(df_ttest)
            else:
                print("t-test requires number of sweeps to match")
        else:
            print("t-test currently only available between exactly 2 shown groups")
        print(f"Heatmap: {round((time.time() - t0) * 1000)} ms")

    def setTableStimVisibility(self, state):
        widget = self.h_splitterMaster.widget(
            1
        )  # Get the second widget in the splitter
        widget.setVisible(state)

    def onSplitterMoved(self, pos, index):
        splitter = self.sender()
        splitter_name = splitter.objectName()
        total_size = sum(splitter.sizes())
        proportions = [size / total_size for size in splitter.sizes()]
        # print(f"{splitter_name}, total_size: {total_size}, Proportions: {proportions}")
        uistate.splitter[splitter_name] = proportions
        uistate.save_cfg(projectfolder=self.dict_folders["project"])

    def toggleViewTool(self, frame):
        self.usage(f"toggleViewTool {frame}")
        uistate.viewTools[frame][1] = not uistate.viewTools[frame][1]
        getattr(self, frame).setVisible(uistate.viewTools[frame][1])
        uistate.save_cfg(projectfolder=self.dict_folders["project"])

    def talkback(self):
        prow = self.get_prow()
        trow = self.get_trow()
        dfmean = self.get_dfmean(prow)
        t_stim = trow["t_stim"]
        t_start = t_stim - 0.002
        t_end = t_stim + 0.018
        dfevent = dfmean[(dfmean["time"] >= t_start) & (dfmean["time"] < t_end)]
        dfevent = dfevent[["time", "voltage"]]
        path_talkback_df = Path(
            f"{self.projects_folder}/talkback/talkback_slice_{prow['ID']}_stim.csv"
        )
        if not path_talkback_df.parent.exists():
            path_talkback_df.parent.mkdir(parents=True, exist_ok=True)
        dfevent.to_csv(path_talkback_df, index=False)
        # save the event data as a dict
        keys = [
            #            't_EPSP_amp', 't_EPSP_amp_method', 't_EPSP_amp_params',
            "t_EPSP_slope_start",
            "t_EPSP_slope_end",  #'t_EPSP_slope_method', 't_EPSP_slope_params',
            #'t_volley_amp', 't_volley_amp_method', 't_volley_amp_params',
            "t_volley_slope_start",
            "t_volley_slope_end",  # 't_volley_slope_method', 't_volley_slope_params'
        ]
        dict_event = {key: trow[key] for key in keys}
        print(f"talkback dict_event: {dict_event}")
        # store dict_event as .csv named after recording_name
        path_talkback = Path(
            f"{self.projects_folder}/talkback/talkback_meta_{prow['ID']}_stim.csv"
        )
        with open(path_talkback, "w") as f:
            json.dump(dict_event, f)

    def darkmode(self):
        if uistate.darkmode:
            self.mainwindow.setStyleSheet("background-color: #2A2A2A; color: #fff;")

            table_style = """
                QTableView::item:selected {
                    background-color: #555;
                    color: #FFF;
                }
                QHeaderView::section {
                    background-color: #333;
                    color: #FFF;
                }
                QTableCornerButton::section {
                    background-color: #333;
                    color: #FFF;
                }
            """
            self.tableProj.setStyleSheet(table_style)
            self.tableStim.setStyleSheet(table_style)
        else:
            self.mainwindow.setStyleSheet("")
            self.tableProj.setStyleSheet("")
            self.tableStim.setStyleSheet("")

        uiplot.styleUpdate()
        self.graphRefresh()

    def zoomAuto(self, reset=False):
        # set and apply Auto-zoom parameters for all axes
        self.usage("zoomAuto")
        prow = self.get_prow()
        if prow is None:
            logger.debug("zoomAuto: no recording selected, skipping")
            return
        dfmean = self.get_dfmean(prow)
        # axm:
        vmin = dfmean["voltage"].min()
        vmax = dfmean["voltage"].max()
        uistate.zoom["mean_xlim"] = (0, prow["sweep_duration"])
        uistate.zoom["mean_ylim"] = (vmin, vmax)
        # axe:
        uistate.zoom["event_ylim"] = (-0.0015, 0.0002)
        uistate.zoom["event_xlim"] = (-0.0012, 0.030)
        # ax1 and ax2
        uistate.zoom["output_ax1_ylim"] = (0, 1.5)
        uistate.zoom["output_ax2_ylim"] = (0, 1.5)
        uistate.zoom["output_xlim"] = (0, prow["sweeps"])
        self.zoomReset()
        return

        if reset:
            uistate.dfv = None
        dfv = self.get_dfv()
        # invalid df or invalid indices
        if dfv is None or len(dfv) == 0:
            return
        # intersect selected indices with df index
        valid_idx = [i for i in uistate.list_idx_select_recs if i in dfv.index]
        if not valid_idx:
            return
        dfv_select = dfv.loc[valid_idx]
        if dfv_select is None or dfv_select.empty:
            return
        # axm:
        vmin = dfv_select["vmin"].min()
        vmax = dfv_select["vmax"].max()
        uistate.zoom["mean_xlim"] = (0, dfv_select["sweep_duration"].max())
        uistate.zoom["mean_ylim"] = (vmin, vmax)
        # axe:
        event_vmin = dfv_select["event_vmin"].min()
        event_vmax = dfv_select["event_vmax"].max()
        margin = 0.05
        uistate.zoom["event_ylim"] = (
            event_vmin - abs(event_vmin * margin),
            event_vmax + abs(event_vmax * margin),
        )

        # ax1 and ax2
        if uistate.checkBox["bin"]:
            first, last = (
                0,
                max(
                    (dfv_select["sweeps"].max() - 1) / uistate.lineEdit["bin_size"] - 1,
                    1,
                ),
            )
        else:
            first, last = 0, max(dfv_select["sweeps"].max() - 1, 1)
        if uistate.checkBox["output_per_stim"]:
            first, last = 1, max(dfv_select["stims"].max(), 2)

        amp_min = 0 if uistate.checkBox["output_ymin0"] else dfv_select["amp_min"].min()
        amp_max = dfv_select["amp_max"].max()
        slope_min = (
            0 if uistate.checkBox["output_ymin0"] else dfv_select["slope_min"].min()
        )
        slope_max = dfv_select["slope_max"].max()

        uistate.zoom["output_ax1_ylim"] = amp_min, amp_max * (1 + margin)
        uistate.zoom["output_ax2_ylim"] = slope_min, slope_max * (1 + margin)
        uistate.zoom["output_xlim"] = first, last

        self.zoomReset()

    def zoomReset(self, axis=None):
        # self.usage("zoomReset")
        if axis is None:
            for axis in [
                uistate.axm,
                uistate.axe,
                uistate.ax1,
                uistate.ax2,
            ]:
                # print(f"zoomReset: all canvases: {axis}")
                self.zoomReset(axis)
            return
        if axis == uistate.axm:
            logger.debug("zoomReset: axm")
            print("zoomReset: axm")
            axis.axes.set_xlim(uistate.zoom["mean_xlim"])
            axis.axes.set_ylim(uistate.zoom["mean_ylim"])
        elif axis == uistate.axe:
            logger.debug("zoomReset: axe")
            print("zoomReset: axe")
            axis.axes.set_xlim(uistate.zoom["event_xlim"])
            axis.axes.set_ylim(uistate.zoom["event_ylim"])
        elif axis == uistate.ax1 or axis == uistate.ax2:
            logger.debug("zoomReset: ax1/ax2")
            print("zoomReset: ax1/ax2")
            uistate.ax1.axes.set_xlim(uistate.zoom["output_xlim"])
            uistate.ax2.axes.set_xlim(uistate.zoom["output_xlim"])
            uistate.ax1.axes.set_ylim(uistate.zoom["output_ax1_ylim"])
            uistate.ax2.axes.set_ylim(uistate.zoom["output_ax2_ylim"])
        else:
            raise ValueError("zoomReset: unknown axis")
        axis.figure.canvas.draw_idle()

    def update_recs2plot(self):
        if uistate.list_idx_select_recs:
            df_project_selected = self.get_df_project().iloc[
                uistate.list_idx_select_recs
            ]
            uistate.df_recs2plot = df_project_selected[
                df_project_selected["sweeps"] != "..."
            ]
            if uistate.df_recs2plot.empty:
                uistate.df_recs2plot = None
        else:
            uistate.df_recs2plot = None

    def viewSettingsChanged(self, key, state):
        self.usage(f"viewSettingsChanged {key}, {state == 2}")
        if key in uistate.checkBox.keys():
            uistate.checkBox[key] = state == 2
            if key == "norm_EPSP":
                self.label_norm_on_sweep.setVisible(state == 2)
                self.label_relative_to.setVisible(state == 2)
                self.lineEdit_norm_EPSP_start.setVisible(state == 2)
                self.lineEdit_norm_EPSP_end.setVisible(state == 2)
            elif key == "splitOddEven":
                self.checkBox_splitOddEven_changed(state)
            elif key == "output_per_stim":
                self.checkBox_output_per_stim_changed(state)
            elif key == "timepoints_per_stim":
                self.checkBox_timepoints_per_stim_changed(state)
            elif key == "output_ymin0":
                self.zoomAuto()
            elif key == "bin":
                self.checkBox_bin_changed(state)
        self.update_show()
        self.mouseoverUpdate()
        uistate.save_cfg(projectfolder=self.dict_folders["project"])

    def groupControlsRefresh(self):
        self.group_controls_remove()
        for group_ID in self.dd_groups.keys():
            self.group_controls_add(group_ID)

    def usage(self, ui_component):  # Talkback function
        logger.debug("usage: %s", ui_component)
        print(f"usage: {ui_component}")
        if not config.talkback:
            return
        if ui_component not in self.dict_usage.keys():
            self.dict_usage[ui_component] = 0
        self.dict_usage[ui_component] += 1
        self.write_usage()

    def write_usage(self):
        path_usage = Path(f"{self.projects_folder}/talkback/usage.yaml")
        if not path_usage.parent.exists():
            path_usage.parent.mkdir(parents=True, exist_ok=True)
        # make sure 'WARNING' and 'alias' are printed first
        top_keys = ["WARNING", "alias"]
        dict_bottom = self.dict_usage.copy()
        top_data = {key: dict_bottom.pop(key, None) for key in top_keys}
        with path_usage.open("w") as file:
            yaml.safe_dump(top_data, file, default_flow_style=False)
            yaml.safe_dump(dict_bottom, file, default_flow_style=False)

    def resetCacheDicts(self):
        self.dict_datas = {}  # all raw data
        self.dict_filters = {}  # all processed data, based on raw data
        self.dict_bins = {}  # all binned data, based on filters
        self.dict_means = {}  # all means
        self.dict_ts = {}  # all timepoints
        self.dict_outputs = {}  # all outputs, x per sweep
        self.dict_group_means = {}  # means of all group outputs
        self.dict_diffs = {}  # all diffs (for paired stim)

    # uisub init refactoring (bootstrap and loadProject live in ProjectMixin)

    def setupTalkback(self):
        path_usage = Path(f"{self.projects_folder}/talkback/usage.yaml")
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if path_usage.exists():
            with path_usage.open("r") as file:
                self.dict_usage = yaml.safe_load(file)
            self.dict_usage[f"last_used_{config.version}"] = now
        else:
            os_name = sys.platform
            self.dict_usage = {
                "WARNING": "Do NOT set your alias to anything that can be used to identify you!",
                "alias": "",
                "ID": str(uuid.uuid4()),
                "os": os_name,
                "ID_created": now,
                f"last_used_{config.version}": now,
            }
        self.write_usage()

    def setSplitterSizes(self, *splitter_names):
        for splitter_name in splitter_names:
            splitter = getattr(self, splitter_name)
            proportions = uistate.splitter[splitter_name]
            widgets = [splitter.widget(i) for i in range(splitter.count())]
            # Store the original size policies of the widgets, and set their size policy to QtWidgets.QSizePolicy.Ignored
            # Set width/height depending on splitter orientation
            sizes = []
            for widget in widgets:
                # original_size_policy = widget.sizePolicy()
                widget.setSizePolicy(
                    QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored
                )
                if splitter.orientation() == QtCore.Qt.Horizontal:
                    sizes.append(
                        int(
                            proportions[widgets.index(widget)]
                            * splitter.sizeHint().width()
                        )
                    )
                else:
                    sizes.append(
                        int(
                            proportions[widgets.index(widget)]
                            * splitter.sizeHint().height()
                        )
                    )
                # widget.setSizePolicy(original_size_policy)
            splitter.setSizes(sizes)

    def setupCanvases(self):
        def setup_graph(graph):
            graph.setLayout(QtWidgets.QVBoxLayout())
            canvas = MplCanvas(parent=graph)
            graph.layout().addWidget(canvas)
            canvas.mpl_connect(
                "button_press_event", lambda event: self.graphClicked(event, canvas)
            )
            canvas.show()
            return canvas

        self.canvasMean = setup_graph(self.graphMean)
        self.canvasEvent = setup_graph(self.graphEvent)
        self.canvasOutput = setup_graph(self.graphOutput)

    def setupMenus(self):
        # File menu
        self.actionNew = QtWidgets.QAction("New project")
        self.actionNew.triggered.connect(self.triggerNewProject)
        self.actionNew.setShortcut("Ctrl+N")
        self.menuFile.addAction(self.actionNew)
        self.actionOpen = QtWidgets.QAction("Open project")
        self.actionOpen.triggered.connect(self.triggerOpenProject)
        self.actionOpen.setShortcut("Ctrl+O")
        self.menuFile.addAction(self.actionOpen)
        self.actionRenameProject = QtWidgets.QAction("Rename project")
        self.actionRenameProject.triggered.connect(self.renameProject)
        self.actionRenameProject.setShortcut("Ctrl+R")
        self.menuFile.addAction(self.actionRenameProject)
        self.actionExit = QtWidgets.QAction("Exit")
        self.actionExit.triggered.connect(QtWidgets.qApp.quit)
        # self.actionExit.setShortcut("Ctrl+Q")  # Set shortcut for Exit
        self.menuFile.addAction(self.actionExit)

        # Edit menu
        # self.actionUndo = QtWidgets.QAction("Undo", self) # TODO: Implement undo
        # self.actionUndo.triggered.connect(self.triggerUndo)
        # self.actionUndo.setShortcut("Ctrl+Z")
        # self.menuEdit.addAction(self.actionUndo)
        self.actionCopyTimepoints = QtWidgets.QAction("Copy timepoints")
        self.actionCopyTimepoints.triggered.connect(self.triggerCopyTimepoints)
        self.actionCopyTimepoints.setShortcut("Ctrl+T")
        self.menuEdit.addAction(self.actionCopyTimepoints)
        self.actionCopyOutput = QtWidgets.QAction("Copy output")
        self.actionCopyOutput.triggered.connect(self.triggerCopyOutput)
        self.actionCopyOutput.setShortcut("Ctrl+C")
        self.menuEdit.addAction(self.actionCopyOutput)

        self.menuEdit.addSeparator()
        self.actionForAllSelected = QtWidgets.QAction(
            "For ALL selected recordings..."
        )  # not connected: submenu header
        self.menuEdit.addAction(self.actionForAllSelected)
        self.actionReAnalyzeRecordings = QtWidgets.QAction("   Reanalyze")
        self.actionReAnalyzeRecordings.triggered.connect(self.triggerReanalyze)
        self.actionReAnalyzeRecordings.setShortcut("A")
        self.menuEdit.addAction(self.actionReAnalyzeRecordings)

        self.actionSweepOpsHeader = QtWidgets.QAction(
            "   — sweep selection —"
        )  # not connected: section header
        self.menuEdit.addAction(self.actionSweepOpsHeader)
        self.actionKeepOnlySelectedSweeps = QtWidgets.QAction(
            "   Keep only selected sweeps"
        )
        self.actionKeepOnlySelectedSweeps.triggered.connect(
            self.triggerKeepSelectedSweeps
        )
        self.menuEdit.addAction(self.actionKeepOnlySelectedSweeps)
        self.actionRemoveSelectedSweeps = QtWidgets.QAction(
            "   Discard selected sweeps"
        )
        self.actionRemoveSelectedSweeps.triggered.connect(
            self.triggerRemoveSelectedSweeps
        )
        self.menuEdit.addAction(self.actionRemoveSelectedSweeps)
        self.actionSplitBySelectedSweeps = QtWidgets.QAction(
            "   Split recordings by selected sweeps"
        )
        self.actionSplitBySelectedSweeps.triggered.connect(
            self.triggerSplitBySelectedSweeps
        )
        self.menuEdit.addAction(self.actionSplitBySelectedSweeps)

        self.actionTimeOpsHeader = QtWidgets.QAction(
            "   — time selection —"
        )  # not connected: section header
        self.menuEdit.addAction(self.actionTimeOpsHeader)
        self.actionKeepOnlySelectedTime = QtWidgets.QAction(
            "   Keep only selected time"
        )
        self.actionKeepOnlySelectedTime.triggered.connect(self.triggerKeepSelectedTime)
        self.menuEdit.addAction(self.actionKeepOnlySelectedTime)
        self.actionDiscardSelectedTime = QtWidgets.QAction("   Discard selected time")
        self.actionDiscardSelectedTime.triggered.connect(
            self.triggerDiscardSelectedTime
        )
        self.menuEdit.addAction(self.actionDiscardSelectedTime)
        self.actionSplitByTime = QtWidgets.QAction("   Split recordings by time")
        self.actionSplitByTime.triggered.connect(self.triggerSplitByTime)
        self.menuEdit.addAction(self.actionSplitByTime)

        # View menu
        self.actionRefresh = QtWidgets.QAction("Refresh Graphs")
        self.actionRefresh.triggered.connect(self.triggerRefresh)
        self.actionRefresh.setShortcut("F5")
        self.menuView.addAction(self.actionRefresh)

        self.actionHeatmap = QtWidgets.QAction("Toggle Heatmap")
        self.actionHeatmap.setCheckable(True)
        self.actionHeatmap.setChecked(uistate.showHeatmap)
        self.actionHeatmap.setShortcut("H")
        self.actionHeatmap.triggered.connect(self.triggerShowHeatmap)
        self.menuView.addAction(self.actionHeatmap)

        self.actionDarkmode = QtWidgets.QAction("Toggle Darkmode")
        self.actionDarkmode.triggered.connect(self.triggerDarkmode)
        self.actionDarkmode.setShortcut("Alt+D")
        self.menuView.addAction(self.actionDarkmode)

        actionTimetable = QtWidgets.QAction("Toggle Timetable")
        actionTimetable.setCheckable(True)
        actionTimetable.setChecked(uistate.showTimetable)
        actionTimetable.setShortcut("Alt+T")
        actionTimetable.triggered.connect(self.triggerShowTimetable)
        self.menuView.addAction(actionTimetable)

        for frame, (text, initial_state) in uistate.viewTools.items():
            action = QtWidgets.QAction(f"Toggle {text}")
            action.setCheckable(True)
            action.setChecked(initial_state)
            action.triggered.connect(
                lambda state, frame=frame: self.toggleViewTool(frame)
            )
            self.menuView.addAction(action)

        # Data menu
        self.actionAddData = QtWidgets.QAction("Add data files")
        self.actionAddData.triggered.connect(self.triggerAddData)
        self.menuData.addAction(self.actionAddData)
        self.actionParse = QtWidgets.QAction("Import all added datafiles")
        self.actionParse.triggered.connect(self.triggerParse)
        self.actionParse.setShortcut("Ctrl+I")
        self.menuData.addAction(self.actionParse)
        self.actionDelete = QtWidgets.QAction("Delete selected data")
        self.actionDelete.triggered.connect(self.triggerDelete)
        self.actionDelete.setShortcut("DEL")
        self.menuData.addAction(self.actionDelete)
        self.actionRenameRecording = QtWidgets.QAction("Rename recording")
        self.actionRenameRecording.triggered.connect(self.triggerRenameRecording)
        self.actionRenameRecording.setShortcut("F2")
        self.menuData.addAction(self.actionRenameRecording)

        # Group menu
        self.actionNewGroup = QtWidgets.QAction("Add a group")
        self.actionNewGroup.triggered.connect(self.triggerNewGroup)
        self.actionNewGroup.setShortcut("+")
        self.menuGroups.addAction(self.actionNewGroup)
        self.actionRemoveEmptyGroup = QtWidgets.QAction("Remove last empty group")
        self.actionRemoveEmptyGroup.triggered.connect(self.triggerRemoveLastEmptyGroup)
        self.actionRemoveEmptyGroup.setShortcut("-")
        self.menuGroups.addAction(self.actionRemoveEmptyGroup)
        self.actionRemoveGroup = QtWidgets.QAction("Force remove last group")
        self.actionRemoveGroup.triggered.connect(self.triggerRemoveLastGroup)
        self.actionRemoveGroup.setShortcut("Ctrl+-")
        self.menuGroups.addAction(self.actionRemoveGroup)
        self.actionClearGroups = QtWidgets.QAction("Clear group(s) in selection")
        self.actionClearGroups.triggered.connect(self.triggerClearGroups)
        self.menuGroups.addAction(self.actionClearGroups)
        self.actionResetGroups = QtWidgets.QAction("Remove all groups")
        self.actionResetGroups.triggered.connect(self.triggerEditGroups)
        self.menuGroups.addAction(self.actionResetGroups)

    def setupTableProj(self):
        try:
            # If tableProj already exists, remove it from the layout
            if hasattr(self, "tableProj"):
                self.verticalLayoutProj.removeWidget(self.tableProj)
                sip.delete(self.tableProj)

            # Creates an instance of custom QTableView to allow drag&drop
            self.tableProj = TableProjSub(parent=self)
            self.verticalLayoutProj.addWidget(self.tableProj)
            self.tableProj.setObjectName("tableProj")

            # Set up the table view
            if not hasattr(self, "df_project"):
                self.df_project = df_projectTemplate()
            self.tablemodel = TableModel(self.df_project)
            self.tableProj.setModel(self.tablemodel)

            # Enable sorting on the QTableView
            self.tableProj.setSortingEnabled(True)

            # Connect events
            self.pushButtonParse.pressed.connect(self.triggerParse)
            self.tableProj.setSelectionBehavior(TableProjSub.SelectRows)
            tableProj_selectionModel = self.tableProj.selectionModel()
            tableProj_selectionModel.selectionChanged.connect(
                self.tableProjSelectionChanged
            )
            self.formatTableLayout()
        except Exception as e:
            print(f"Error setting up tableProj: {e}")

    def setupTableStim(self):
        self.tableStimModel = TableModel(pd.DataFrame([uistate.default_dict_t]))
        self.tableStim.setModel(self.tableStimModel)
        self.tableStim.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.tableStim.verticalHeader().hide()
        tableStim_selectionModel = self.tableStim.selectionModel()
        tableStim_selectionModel.selectionChanged.connect(self.stimSelectionChanged)

    def formatTableLayout(self):
        logger.debug("formatTableLayout")
        print("formatTableLayout")

        self.tableProj.setSizePolicy(
            QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred
        )
        self.tableProj.verticalHeader().hide()

        df_p = self.df_project
        header = self.tableProj.horizontalHeader()

        # ordered, visible columns
        column_order = [
            "status",
            "recording_name",
            "groups",
            "stims",
            "sweeps",
            "sweep_duration",
        ]
        if uistate.checkBox["paired_stims"]:
            column_order.append("Tx")

        col_indices = [df_p.columns.get_loc(name) for name in column_order]

        # Show/hide columns and set resize behavior
        num_columns = df_p.shape[1]
        for col in range(num_columns):
            if col in col_indices:
                header.setSectionResizeMode(col, QtWidgets.QHeaderView.ResizeToContents)
                self.tableProj.setColumnHidden(col, False)
            else:
                self.tableProj.setColumnHidden(col, True)

        self.tableProj.resizeColumnsToContents()

        # Reorder visible columns
        for i, col_index in enumerate(col_indices):
            header.moveSection(header.visualIndex(col_index), i)

    def formatTableStimLayout(self, dft):
        header = self.tableStim.horizontalHeader()
        column_order = [
            "stim",
            "t_stim",
            "t_EPSP_slope_start",
            "t_EPSP_slope_end",
            "t_EPSP_slope_method",
            "t_EPSP_amp",
            "t_EPSP_amp_method",
            "t_volley_slope_start",
            "t_volley_slope_end",
            "t_volley_slope_method",
            "t_volley_amp",
            "t_volley_amp_method",
        ]
        col_indices = [
            dft.columns.get_loc(col) for col in column_order if col in dft.columns
        ]
        num_columns = dft.shape[1]
        for col in range(num_columns):
            if col in col_indices:
                header.setSectionResizeMode(col, QtWidgets.QHeaderView.ResizeToContents)
                self.tableStim.setColumnHidden(col, False)
            else:
                self.tableStim.setColumnHidden(col, True)
        for i, col_index in enumerate(col_indices):
            header.moveSection(header.visualIndex(col_index), i)
        self.tableStim.resizeColumnsToContents()

    def setupFolders(self):
        self.dict_folders = self.build_dict_folders()
        # DEBUG: clear cache and timepoints folders
        if config.clear_cache:
            self.deleteFolder(self.dict_folders["cache"])
        if config.clear_timepoints:
            self.deleteFolder(self.dict_folders["timepoints"])
        if config.clear_project_folder:
            self.deleteFolder(self.dict_folders["project"])
        # Make sure the necessary folders exist
        if not os.path.exists(self.projects_folder):
            os.makedirs(self.projects_folder)
        if not os.path.exists(self.dict_folders["cache"]):
            os.makedirs(self.dict_folders["cache"])
        if not os.path.exists(self.dict_folders["timepoints"]):
            os.makedirs(self.dict_folders["timepoints"])

    def setupToolBar(self):
        # apply viewstates for tool frames in the toolbar
        for frame, (text, state) in uistate.viewTools.items():
            getattr(self, frame).setVisible(state)
        # TODO:
        # connect paired stim checkbox and flip button to local functions
        # self.checkBox_paired_stims.setChecked(uistate.checkBox['paired_stims'])
        # self.checkBox_paired_stims.stateChanged.connect(lambda state: self.checkBox_paired_stims_changed(state))
        # self.pushButton_paired_data_flip.pressed.connect(self.pushButton_paired_data_flip_pressed)

    def build_dict_folders(self):
        dict_folders = {
            "project": self.projects_folder
            / self.projectname,  # path to project folder
            "data": self.projects_folder
            / self.projectname
            / "data",  # path to project data subfolder
            "timepoints": self.projects_folder
            / self.projectname
            / "timepoints",  # path to project timepoints subfolder
            "cache": self.projects_folder
            / f"cache {config.version}"
            / self.projectname,  # path to project cache subfolder
        }
        return dict_folders

    def connectUIstate(self, disconnect=False):  # ternary (dis)connect of UI elements
        # checkBoxes
        for key, value in uistate.checkBox.items():
            checkBox = getattr(self, f"checkBox_{key}")
            checkBox.stateChanged.disconnect() if disconnect else checkBox.stateChanged.connect(
                lambda state, key=key: self.viewSettingsChanged(key, state)
            )
        # lineEdits
        for lineEdit in [
            self.lineEdit_split_at_time,
            self.lineEdit_import_gain,
        ]:
            lineEdit.editingFinished.disconnect() if disconnect else lineEdit.editingFinished.connect(
                lambda le=lineEdit: self.editImportOptions(le)
            )
        for lineEdit in [
            self.lineEdit_mean_selection_start,
            self.lineEdit_mean_selection_end,
        ]:
            lineEdit.editingFinished.disconnect() if disconnect else lineEdit.editingFinished.connect(
                lambda le=lineEdit: self.editMeanSelectRange(le)
            )
        for lineEdit in [
            self.lineEdit_sweeps_range_from,
            self.lineEdit_sweeps_range_to,
        ]:
            lineEdit.editingFinished.disconnect() if disconnect else lineEdit.editingFinished.connect(
                lambda le=lineEdit: self.editSweepSelectRange(le)
            )
        for lineEdit in [
            self.lineEdit_norm_EPSP_start,
            self.lineEdit_norm_EPSP_end,
        ]:
            lineEdit.editingFinished.disconnect() if disconnect else lineEdit.editingFinished.connect(
                lambda le=lineEdit: self.editNormRange(le)
            )
        for lineEdit in [
            self.lineEdit_EPSP_amp_halfwidth,
            self.lineEdit_volley_amp_halfwidth,
        ]:
            lineEdit.editingFinished.disconnect() if disconnect else lineEdit.editingFinished.connect(
                lambda le=lineEdit: self.editAmpHalfwidth(le)
            )
        for lineEdit in [
            self.lineEdit_bin_size,
        ]:
            lineEdit.editingFinished.disconnect() if disconnect else lineEdit.editingFinished.connect(
                lambda le=lineEdit: self.editBinSize(le)
            )

        # pushButtons
        for str_button, str_function in uistate.pushButtons.items():
            button, func = getattr(self, str_button), getattr(self, str_function)
            button.pressed.disconnect() if disconnect else button.pressed.connect(func)
        # SplitterMoved
        for splitter_name in ["h_splitterMaster", "v_splitterGraphs"]:
            splitter = getattr(self, splitter_name)
            splitter.splitterMoved.disconnect() if disconnect else splitter.splitterMoved.connect(
                self.onSplitterMoved
            )

    def applyConfigStates(self):
        # Disconnect signals to prevent editingFinished from triggering from .setText
        self.connectUIstate(disconnect=True)

        for key, value in uistate.checkBox.items():
            checkBox = getattr(self, f"checkBox_{key}")
            checkBox.setChecked(value)
        norm = uistate.checkBox["norm_EPSP"]
        self.label_norm_on_sweep.setVisible(norm)
        self.label_relative_to.setVisible(norm)
        self.lineEdit_norm_EPSP_start.setVisible(norm)
        self.lineEdit_norm_EPSP_end.setVisible(norm)
        self.lineEdit_norm_EPSP_start.setText(f"{uistate.lineEdit['norm_EPSP_from']}")
        self.lineEdit_norm_EPSP_end.setText(f"{uistate.lineEdit['norm_EPSP_to']}")
        self.lineEdit_split_at_time.setText(
            f"{uistate.lineEdit['split_at_time'] * 1000:g}"
        )
        self.lineEdit_EPSP_amp_halfwidth.setText(
            f"{uistate.lineEdit['EPSP_amp_halfwidth_ms']}"
        )
        self.lineEdit_volley_amp_halfwidth.setText(
            f"{uistate.lineEdit['volley_amp_halfwidth_ms']}"
        )

        # apply splitter proportions from project config
        self.setSplitterSizes("h_splitterMaster", "v_splitterGraphs")
        self.connectUIstate()

    # trigger functions TODO: break out the big ones to separate functions!

    def groupCheckboxChanged(self, state, group_ID):
        logger.debug("groupCheckboxChanged: %s = %s", group_ID, state)
        print(f"groupCheckboxChanged: {str(group_ID)} = {state}")
        self.dd_groups[group_ID]["show"] = state == 2
        self.group_save_dd()
        self.update_show()
        self.mouseoverUpdate()

    def checkBox_paired_stims_changed(self, state):
        self.usage("checkBox_paired_stims_changed")
        uistate.checkBox["paired_stims"] = bool(state)
        print(f"checkBox_paired_stims_changed: {uistate.checkBox['paired_stims']}")
        # TODO: reconnect this

    def trigger_export_selection(self):
        self.usage("trigger_export_selection - DEPRECATED")
        # self.export_selection()

    def trigger_export_groups(self):
        self.usage("trigger_export_groups - DEPRECATED")
        # self.export_groups()

    def triggerGroupRename(self, group_ID):
        self.usage("triggerGroupRename")
        RenameDialog = InputDialogPopup()
        new_group_name = RenameDialog.showInputDialog(title="Rename group", query="")
        self.group_rename(group_ID, new_group_name)

    def triggerStimDetect(self):
        self.usage("triggerStimDetect")
        self.stimDetect()

    def trigger_set_sweeps_even(self):
        self.usage("trigger_set_sweeps_even")
        self.sweepsSelect(even=True)

    def trigger_set_sweeps_odd(self):
        self.usage("trigger_set_sweeps_odd")
        self.sweepsSelect(even=False)

    def trigger_set_EPSP_amp_width_all(self):
        self.usage("trigger_set_EPSP_amp_width_all")
        self.recalculate()

    def trigger_set_volley_amp_width_all(self):
        self.usage("trigger_set_volley_amp_width_all")
        self.recalculate()

    def trigger_set_norm_range_all(self):
        self.usage("trigger_set_norm_range_all")
        self.recalculate()

    def trigger_set_bin_size_all(self):
        self.usage("trigger_set_bin_size_all")
        uistate.checkBox["bin"] = True
        self.recalculate()

    def triggerRefresh(self):
        self.usage("refresh graphs")
        selection = uistate.list_idx_select_recs
        self.tableProj.clearSelection()
        self.recalculate()
        uistate.list_idx_select_recs = selection
        self.tableUpdate()
        self.tableProjSelectionChanged()

    def triggerDarkmode(self):
        uistate.darkmode = not uistate.darkmode
        self.usage(f"triggerDarkmode set to {uistate.darkmode}")
        self.write_bw_cfg()
        self.darkmode()

    def triggerShowHeatmap(self):
        self.usage("triggerShowHeatmap")
        self.toggleHeatmap()

    def triggerShowTimetable(self):
        self.usage("triggerShowTimetable")
        uistate.showTimetable = not uistate.showTimetable
        if uistate.dict_rec_show:
            self.tableProjSelectionChanged()
        self.write_bw_cfg()
        self.setTableStimVisibility(uistate.showTimetable)

    def triggerCopyTimepoints(self):
        self.usage("triggerCopyTimepoints")
        self.copy_dft()

    def triggerCopyOutput(self):
        self.usage("triggerCopyOutput")
        self.copy_output()

    def pushButton_paired_data_flip_pressed(self):
        self.usage("pushButton_paired_data_flip_pressed")
        self.flipCI()

    def triggerRenameRecording(self):
        self.usage("triggerRenameRecording")
        self.renameRecording()

    def triggerClearGroups(self):
        self.usage("triggerClearGroups")
        if uistate.list_idx_select_recs:
            self.clearGroupsByRow(uistate.list_idx_select_recs)
            self.tableUpdate()
            self.mouseoverUpdate()
        else:
            print("No files selected.")

    def triggerEditGroups(self):  # Open groups UI (not built)
        self.usage("triggerEditGroups")
        # Placeholder: For now, delete all buttons and groups
        self.group_controls_remove()
        self.group_remove()
        self.tableUpdate()
        self.mouseoverUpdate()

    def triggerNewGroup(self):
        self.usage("triggerNewGroup")
        self.group_new()

    def triggerRemoveLastGroup(self):
        self.usage("triggerRemoveLastGroup")
        self.group_remove_last()

    def triggerRemoveLastEmptyGroup(self):
        self.usage("triggerRemoveLastEmptyGroup")
        self.group_remove_last_empty()

    def triggerDelete(self):
        self.usage("triggerDelete")
        self.deleteSelectedRows()

    def triggerRenameProject(self):  # renameProject
        self.usage("triggerRenameProject")
        self.inputProjectName.setReadOnly(False)
        self.inputProjectName.selectAll()  # Select all text
        self.inputProjectName.setFocus()  # Set focus
        try:  # Only disconnect if connected
            self.inputProjectName.editingFinished.disconnect()
        except TypeError:
            pass  # Ignore the TypeError that is raised when the signal isn't connected to any slots
        finally:
            self.inputProjectName.editingFinished.connect(self.renameProject)

    def triggerNewProject(self):
        self.usage("triggerNewProject")
        self.newProject()

    def triggerOpenProject(self):  # open folder selector dialog
        self.usage("triggerOpenProject")
        self.dialog = QtWidgets.QDialog()
        print(f"self.projects_folder: {self.projects_folder}")
        str_projectfolder = str(
            QtWidgets.QFileDialog.getExistingDirectory(
                self.dialog,
                "Open Directory",
                str(self.projects_folder),
                QtWidgets.QFileDialog.ShowDirsOnly
                | QtWidgets.QFileDialog.DontResolveSymlinks
                | QtWidgets.QFileDialog.DontUseNativeDialog,
            )
        )
        logger.debug("Received projectfolder: %s", str_projectfolder)
        print(f"Received projectfolder: {str_projectfolder}")
        projectpath = Path(str_projectfolder) / "project.brainwash"
        if projectpath.exists():
            logger.debug("Found project %s, loading...", str_projectfolder)
            print(f"Found project {str_projectfolder}, loading...")
            self.openProject(str_projectfolder)
        else:
            logger.warning("No project found in %s", str_projectfolder)
            print(f"No project found in {str_projectfolder}")

    def triggerAddData(self):  # creates file tree for file selection
        self.usage("triggerAddData")
        self.dialog = QtWidgets.QDialog()
        self.ftree = Filetreesub(self.dialog, parent=self, folder=self.user_documents)
        self.dialog.show()

    def triggerParse(self):  # parse non-parsed files and folders in self.df_project
        if uistate.frozen:
            print(
                "triggerParse: UI is frozen (already parsing), ignoring duplicate call"
            )
            return
        self.usage("triggerParse")
        self.mouseoverDisconnect()
        self.parseData()
        self.setButtonParse()

    def triggerReanalyze(self):
        self.usage("triggerReanalyze")
        selection = uistate.list_idx_select_recs
        self.reanalyze_recordings()
        self.tableProj.clearSelection()
        uistate.list_idx_select_recs = selection
        self.tableUpdate()
        self.tableProjSelectionChanged()

    # triggerKeepSelectedSweeps, triggerRemoveSelectedSweeps, triggerSplitBySelectedSweeps,
    # sweep_selection_valid, sweep_removal_valid_confirmed → SweepOpsMixin (ui_sweep_ops.py)

    def reanalyze_recordings(self):
        self.usage("reanalyze_recordings")
        n_recs = len(uistate.list_idx_select_recs)
        print(f"Reanalyzing {n_recs} selected recording{'s' if n_recs != 1 else ''}...")
        # purge df timepoints and cache for selected recordings
        for rec_idx in uistate.list_idx_select_recs:
            p_row = self.df_project.iloc[rec_idx]
            rec_name = p_row["recording_name"]
            # delete timepoints file
            timepoints_file = self.dict_folders["timepoints"] / (rec_name + ".parquet")
            if timepoints_file.exists():
                timepoints_file.unlink()
                logger.debug("Deleted timepoints file: %s", timepoints_file)
                print(f"Deleted timepoints file: {timepoints_file}")
            # delete cached output file
            cache_file = self.dict_folders["cache"] / (rec_name + "_output.parquet")
            if cache_file.exists():
                cache_file.unlink()
                logger.debug("Deleted cached output file: %s", cache_file)
                print(f"Deleted cached output file: {cache_file}")
            self.set_rec_status(rec_name)
        self.resetCacheDicts()
        self.recalculate()  # outputs, binning, group handling

    # sweep_shift_gaps, sweep_remove_by_ID, sweep_keep_selected, sweep_remove_selected,
    # sweep_unselect, sweep_split_by_selected → SweepOpsMixin (ui_sweep_ops.py)

    def duplicate_recording(self, source_p_row, new_name=None):
        source_name = source_p_row["recording_name"]
        if new_name is None:
            new_name = f"{source_name}_copy"
        if new_name in self.df_project["recording_name"].values:
            print(
                f"duplicate_recording: recording name '{new_name}' already exists, choose a different name."
            )
            return
        df_proj_new_row = source_p_row.copy()
        df_proj_new_row["ID"] = str(uuid.uuid4())  # new unique ID
        df_proj_new_row["recording_name"] = new_name
        # Update data files: copy source data file to new data file
        df_project = self.get_df_project()
        self.df_project = pd.concat(
            [df_project, pd.DataFrame([df_proj_new_row])], ignore_index=True
        )
        self.save_df_project()
        df_data = self.get_dfdata(source_p_row)
        self.df2file(df_data, new_name, key="data")  # persist data file
        dfmean, i_stim = parse.build_dfmean(df_data)
        self.df2file(dfmean, new_name, key="mean")  # persist mean
        df = parse.zeroSweeps(df_data, i_stim=i_stim)
        self.df2file(df, new_name, key="filter")  # persist zeroed
        return

    def create_recording(self, df_proj_row, rec, df_raw):
        def create_row(df_proj_row, new_name, dict_meta):
            df_proj_new_row = df_proj_row.copy()
            df_proj_new_row["ID"] = str(uuid.uuid4())
            df_proj_new_row["status"] = "Read"
            df_proj_new_row["recording_name"] = new_name
            df_proj_new_row["sweeps"] = dict_meta.get("nsweeps", None)
            df_proj_new_row["channel"] = ""  # dict_meta.get('channel', None)
            df_proj_new_row["stim"] = ""  # dict_meta.get('stim', None)
            df_proj_new_row["sweep_duration"] = dict_meta.get("sweep_duration", None)
            df_proj_new_row["resets"] = ""  # dict_meta.get('resets', None)
            return df_proj_new_row

        self.df2file(df_raw, rec, key="data")  # persist raws
        dfmean, i_stim = parse.build_dfmean(df_raw)
        self.df2file(dfmean, rec, key="mean")  # persist mean
        df = parse.zeroSweeps(df_raw, i_stim=i_stim)
        self.df2file(df, rec, key="filter")  # persist zeroed
        dict_meta = parse.metadata(df)  # extract metadata
        # TODO: create unique recording names
        df_proj_new_row = create_row(
            df_proj_row=df_proj_row, new_name=rec, dict_meta=dict_meta
        )
        return df_proj_new_row

    # recalculate → DataFrameMixin (ui_data_frames.py)

    def editAmpHalfwidth(self, lineEdit):
        lineEditName = lineEdit.objectName()
        self.usage(f"editAmpHalfwidth {lineEditName}")
        try:
            num = max(0, float(lineEdit.text()))
        except ValueError:
            num = 0
        lineEdit.setText(str(num))
        if lineEditName == "lineEdit_EPSP_amp_halfwidth":
            uistate.lineEdit["EPSP_amp_halfwidth_ms"] = num
        elif lineEditName == "lineEdit_volley_amp_halfwidth":
            uistate.lineEdit["volley_amp_halfwidth_ms"] = num

    def editSort(self, lineEdit, start, end, request="int"):
        def str2num(text):
            try:
                if request == "float":
                    return max(0, float(text.replace(",", ".")))
                else:
                    return max(0, int(text.replace(",", ".")))
            except ValueError:
                return 0

        def num2str(num):
            if request == "float":
                return str(max(0, float(num)))
            else:
                return str(max(0, int(num)))

        num = str2num(lineEdit.text())
        if lineEdit.objectName() == start.objectName():
            pair = str2num(end.text())
        else:
            pair = str2num(start.text())
        low, high = min(num, pair), max(num, pair)
        start.setText(num2str(low))
        end.setText(num2str(high))
        return low, high

    def editImportOptions(self, lineEdit):
        self.usage("editImportOptions")
        lineEditName = lineEdit.objectName()
        try:
            text = lineEdit.text().replace(",", ".")
            num = max(0, float(text))
        except ValueError:
            num = 0
        lineEdit.setText(str(num))
        if lineEditName == "lineEdit_split_at_time":
            uistate.lineEdit["split_at_time"] = float(lineEdit.text()) / 1000.0
            if (
                uistate.lineEdit["split_at_time"] is not None
                and uistate.lineEdit["split_at_time"] != 0
            ):
                uistate.checkBox["splitOddEven"] = False
                self.checkBox_splitOddEven.setChecked(False)
        elif lineEditName == "lineEdit_import_gain":
            uistate.lineEdit["import_gain"] = float(lineEdit.text())

    def editMeanSelectRange(self, lineEdit):
        self.usage("editMeanSelectRange")
        low, high = self.editSort(
            lineEdit,
            start=self.lineEdit_mean_selection_start,
            end=self.lineEdit_mean_selection_end,
            request="float",
        )
        # lineEdits display ms; uistate stores s
        uistate.x_select["mean_start"] = low / 1000.0
        uistate.x_select["mean_end"] = high / 1000.0 if high else None
        uiplot.xSelect(uistate.axm.figure.canvas)

    def editSweepSelectRange(self, lineEdit):
        self.usage("editSweepSelectRange")
        low, high = self.editSort(
            lineEdit,
            start=self.lineEdit_sweeps_range_from,
            end=self.lineEdit_sweeps_range_to,
        )
        uistate.x_select["output_start"], uistate.x_select["output_end"] = low, high
        uistate.x_select["output"] = set(range(low, high + 1))
        uiplot.xSelect(uistate.ax1.figure.canvas)
        uiplot.update_axe_mean()

    def editNormRange(self, lineEdit):
        self.usage("editNormRange")
        _ = self.editSort(
            lineEdit,
            start=self.lineEdit_norm_EPSP_start,
            end=self.lineEdit_norm_EPSP_end,
        )
        # TODO: show selection on graph

    def editBinSize(self, lineEdit):
        self.usage("editBinSize")
        try:
            num = max(2, int(lineEdit.text()))
        except ValueError:
            num = 10
        lineEdit.setText(str(num))
        uistate.lineEdit["bin_size"] = num
        print(f"editBinSize: {num}")
        uistate.save_cfg(projectfolder=self.dict_folders["project"])

    def copy_dft(self):
        # get selected dft(s) and copy to clipboard
        if len(uistate.list_idx_select_recs) < 1:
            print("copy_dft: nothing selected.")
            return
        selected_dfts = pd.DataFrame()
        for rec in uistate.list_idx_select_recs:
            p_row = self.get_df_project().loc[rec]
            dft = self.get_dft(p_row)
            dft.insert(0, "recording_name", p_row["recording_name"])
            selected_dfts = pd.concat([selected_dfts, dft], ignore_index=True)
        selected_dfts.to_clipboard(index=False)

    def copy_output(self):
        if len(uistate.list_idx_select_recs) < 1:
            print("copy_output: nothing selected.")
            return
        selected_outputs = pd.DataFrame()
        for rec in uistate.list_idx_select_recs:
            p_row = self.get_df_project().loc[rec]
            output = self.get_dfoutput(p_row)
            output.insert(0, "recording_name", p_row["recording_name"])
            selected_outputs = pd.concat([selected_outputs, output], ignore_index=True)
        selected_outputs.to_clipboard(index=False)

    def stimDetect(self):
        if not uistate.list_idx_select_recs:
            print("No files selected.")
            return
        df_p = self.get_df_project()
        for index in uistate.list_idx_select_recs:
            p_row = df_p.loc[index]
            old_df_t = self.get_dft(p_row)
            rec_name = p_row["recording_name"]
            rec_ID = p_row["ID"]
            stims = p_row["stims"]
            if p_row["sweeps"] == "...":
                print(f"{rec_name} not parsed yet.")
                continue
            print(f"Detecting stims for {rec_name}")
            if uistate.x_select["mean_start"] is not None:
                print(
                    f" - range: {uistate.x_select['mean_start']} to {uistate.x_select['mean_end']}"
                )
            dfmean = self.get_dfmean(p_row)
            if (
                uistate.x_select["mean_start"] is not None
                and uistate.x_select["mean_end"] is not None
            ):
                dfmean_range = dfmean[
                    (dfmean["time"] >= uistate.x_select["mean_start"])
                    & (dfmean["time"] <= uistate.x_select["mean_end"])
                ].reset_index(drop=True)
            else:
                dfmean_range = dfmean
            default_dict_t = uistate.default_dict_t.copy()  # Default sizes
            print(
                f"stimDetect: {rec_name} calling find_events within range:\n{uistate.x_select}"
            )
            new_df_t = analysis.find_events(
                dfmean=dfmean_range, default_dict_t=default_dict_t, verbose=False
            )
            if new_df_t is None:
                print(f"StimDetect: No stims found for {rec_name}.")
                continue
            if uistate.checkBox["timepoints_per_stim"] or stims == 1:
                self.set_dft(rec_name, new_df_t)
            else:
                dfoutput = self.get_dfoutput(p_row)
                print(
                    f"stimDetect: {rec_name} calling set_uniformTimepoints with df_t:\n{new_df_t}"
                )
                # list_obsolete_stim_idx: a list of idx of old_df_t rows, that have a t_stim that isn't in new_df_t
                list_obsolete_stim_idx = [
                    i
                    for i, row in old_df_t.iterrows()
                    if row["t_stim"] not in new_df_t["t_stim"].values
                ]
                if list_obsolete_stim_idx:
                    print(f"Obsolete stims: {list_obsolete_stim_idx}")
                    for idx in list_obsolete_stim_idx:
                        dfoutput = dfoutput.drop(idx)
                        print(f" - removed idx {idx} from dfoutput")
                    dfoutput = dfoutput.reset_index(drop=True)
                    dfoutput["stim"] = new_df_t["stim"]
                self.set_uniformTimepoints(p_row=p_row, dft=new_df_t, dfoutput=dfoutput)
            df_p.loc[p_row["ID"] == df_p["ID"], "stims"] = len(new_df_t)
            self.set_df_project(df_p)
            uiplot.unPlot(rec_ID)
            dfoutput = self.get_dfoutput(p_row)
            self.persistOutput(p_row["recording_name"], dfoutput)
            uiplot.addRow(p_row, new_df_t, dfmean, dfoutput)
        uistate.list_idx_select_stims = [0]
        p_row = df_p.loc[uistate.list_idx_select_recs[0]]
        df_t = self.get_dft(p_row)
        self.tableStimModel.setData(df_t)
        self.tableStim.selectRow(0)
        # unplot and replot all affected recordings
        self.update_show(reset=True)
        self.mouseoverUpdate()

    def addData(self, dfAdd):  # concatenate dataframes of old and new data
        # Check for unique names in dfAdd, vs df_p and dfAdd
        # Adds (<lowest integer that makes unique>) to the end of non-unique recording_names
        df_p = self.get_df_project()
        list_recording_names = set(df_p["recording_name"])
        for index, row in dfAdd.iterrows():
            check_recording_name = row["recording_name"]
            if check_recording_name.endswith("_mean.parquet"):
                print(
                    "recording_name must not end with _mean.parquet - appending _X"
                )  # must not collide with internal naming
                check_recording_name = check_recording_name + "_X"
                dfAdd.at[index, "recording_name"] = check_recording_name
            if check_recording_name in list_recording_names:
                # print(index, check_recording_name, "already exists!")
                i = 1
                new_recording_name = check_recording_name + "(" + str(i) + ")"
                while new_recording_name in list_recording_names:
                    i += 1
                    new_recording_name = check_recording_name + "(" + str(i) + ")"
                print("New name:", new_recording_name)
                list_recording_names.add(new_recording_name)
                dfAdd.at[index, "recording_name"] = new_recording_name
            else:
                list_recording_names.add(check_recording_name)
        df_p = pd.concat([df_p, dfAdd])
        df_p.reset_index(drop=True, inplace=True)
        df_p["groups"] = df_p["groups"].fillna(" ")
        df_p["sweeps"] = df_p["sweeps"].fillna("...")
        self.set_df_project(df_p)
        self.tableFormat()
        logger.debug("addData: %s", self.get_df_project())
        print("addData:", self.get_df_project())

    def renameRecording(self):
        # renames all instances of selected recording_name in df_project, and their associated files
        if len(uistate.list_idx_select_recs) != 1:
            print("Rename: please select one row only for renaming.")
            return
        df_p = self.get_df_project()
        old_recording_name = df_p.at[uistate.list_idx_select_recs[0], "recording_name"]
        RenameDialog = InputDialogPopup()
        new_recording_name = RenameDialog.showInputDialog(
            title="Rename recording", query=old_recording_name
        )
        # check if the new name is a valid filename
        if (
            new_recording_name is not None
            and re.match(r"^[a-zA-Z0-9_ -]+$", str(new_recording_name)) is not None
        ):
            list_recording_names = set(df_p["recording_name"])
            if not new_recording_name in list_recording_names:  # prevent duplicates
                self.rename_files_by_rec_name(
                    old_name=old_recording_name, new_name=new_recording_name
                )
                df_p.at[uistate.list_idx_select_recs[0], "recording_name"] = (
                    new_recording_name
                )
                # For paired recordings: also rename any references to old_recording_name in df_p['paired_recording']
                df_p.loc[
                    df_p["paired_recording"] == old_recording_name, "paired_recording"
                ] = new_recording_name
                self.set_df_project(df_p)
                self.tableUpdate()
                self.update_recs2plot()
                old_recording_ID = df_p.at[uistate.list_idx_select_recs[0], "ID"]
                uiplot.unPlot(old_recording_ID)
                self.graphUpdate(row=df_p.loc[uistate.list_idx_select_recs[0]])
                self.update_show(reset=True)
            else:
                print(f"new_recording_name {new_recording_name} already exists")
        else:
            print(f"new_recording_name {new_recording_name} is not a valid filename")

    def rename_files_by_rec_name(self, old_name, new_name):
        for folder_name, file_suffix in [
            ("data", ".parquet"),
            ("timepoints", ".parquet"),
            ("cache", "_mean.parquet"),
            ("cache", "_filter.parquet"),
            ("cache", "_bin.parquet"),
            ("cache", "_output.parquet"),
        ]:
            old_file_path = Path(
                self.dict_folders[folder_name] / (old_name + file_suffix)
            )
            new_file_path = Path(
                self.dict_folders[folder_name] / (new_name + file_suffix)
            )
            if old_file_path.exists():
                old_file_path.rename(new_file_path)
            elif folder_name == "data":
                print(f"recording_rename_files: file not found: {old_file_path}")
                raise FileNotFoundError

    def deleteSelectedRows(self):
        if not uistate.list_idx_select_recs:
            print("No files selected.")
            return
        df_p = self.get_df_project()
        for index in uistate.list_idx_select_recs:
            rec_name = df_p.at[index, "recording_name"]
            rec_ID = df_p.at[index, "ID"]
            sweeps = df_p.at[index, "sweeps"]
            if sweeps != "...":  # if the file is parsed:
                print(f"Deleting {rec_name}...")
                self.purgeRecordingData(rec_ID, rec_name)
                # this also purges group cache and unplots the group
                uiplot.unPlot(rec_ID)  # remove plotted lines
        # store the ID of the line below the last selected row
        reselect_ID = None
        if uistate.list_idx_select_recs[-1] < (len(df_p) - 1):
            reselect_ID = df_p.at[uistate.list_idx_select_recs[-1] + 1, "ID"]
        df_p.drop(uistate.list_idx_select_recs, inplace=True)
        df_p.reset_index(inplace=True, drop=True)
        self.set_df_project(df_p)
        self.tableUpdate()
        # reselect the line below the last selected row
        if reselect_ID is not None:
            uistate.list_idx_select_recs = [df_p[df_p["ID"] == reselect_ID].index[0]]
        self.tableProjSelectionChanged()

    def purgeRecordingData(self, rec_ID, rec_name):
        def removeFromCache(cache_name):
            cache = getattr(self, cache_name)
            if rec_name in cache.keys():
                cache.pop(rec_name, None)

        def removeFromDisk(folder_name, file_suffix):
            file_path = Path(self.dict_folders[folder_name] / (rec_name + file_suffix))
            if file_path.exists():
                file_path.unlink()
            else:
                print(f"purgeRecordingData: file not found: {file_path}")

        groups2purge = self.get_groupsOfRec(rec_ID)
        if (
            groups2purge
        ):  # if rec_ID is in groups, purge those group caches and update dd_groups
            # print(f"purgeRecordingData: {rec_name} in groups: {groups2purge}")
            for (
                group_ID
            ) in groups2purge:  # remove rec_ID from rec_IDs of all affected groups
                print(f"purgeRecordingData: pre  {self.dd_groups[group_ID]['rec_IDs']}")
                self.dd_groups[group_ID]["rec_IDs"].remove(rec_ID)
                print(f"purgeRecordingData: post {self.dd_groups[group_ID]['rec_IDs']}")
            self.group_save_dd()
            self.group_cache_purge(groups2purge)
        # clear recording caches
        for cache_name in [
            "dict_datas",
            "dict_means",
            "dict_filters",
            "dict_ts",
            "dict_bins",
            "dict_outputs",
        ]:
            removeFromCache(cache_name)
        for folder_name, file_suffix in [
            ("data", ".parquet"),
            ("timepoints", ".parquet"),
            ("cache", "_mean.parquet"),
            ("cache", "_filter.parquet"),
            ("cache", "_bin.parquet"),
            ("cache", "_output.parquet"),
        ]:
            removeFromDisk(folder_name, file_suffix)

    def parseData(self):
        if (
            hasattr(self, "_current_parse_thread")
            and self._current_parse_thread is not None
        ):
            print("parseData: already parsing, ignoring duplicate call")
            return
        self.uiFreeze()  # Thawed at the end of graphPreload()
        # Clean up any existing thread before starting a new one
        self._cleanup_threads()
        df_p = self.get_df_project()
        df_p_to_update = df_p[df_p["sweeps"] == "..."].copy()
        if len(df_p_to_update) > 0:
            print(f"parseData: {len(df_p_to_update)} files to parse.")
            thread = ParseDataThread(df_p_to_update, self.dict_folders, self)
            self._current_parse_thread = thread  # Store reference for use in callbacks
            thread.progress.connect(self.updateProgressBar)
            thread.finished.connect(self.onParseDataFinished)
            thread.finished.connect(thread.deleteLater)  # Auto-cleanup when done
            thread.finished.connect(
                lambda: (
                    self._threads.remove(thread) if thread in self._threads else None
                )
            )
            thread.finished.connect(
                lambda: setattr(self, "_current_parse_thread", None)
            )
            self._threads.append(thread)
            thread.start()
            self.progressBarManager = ProgressBarManager(
                self.progressBar, len(df_p_to_update)
            )
            self.progressBarManager.__enter__()

    def updateProgressBar(self, i):
        self.progressBarManager.update(i, "Parsing file ")

    def onParseDataFinished(self):
        print("onParseDataFinished: entered")
        self.progressBarManager.__exit__(None, None, None)
        if (
            hasattr(self, "_current_parse_thread")
            and self._current_parse_thread is not None
        ):
            thread = self._current_parse_thread
            if thread.rows:
                rows2add = pd.concat(thread.rows, axis=1).transpose()
                df_p = self.get_df_project()
                df_p = pd.concat([df_p[df_p["sweeps"] != "..."], rows2add]).reset_index(
                    drop=True
                )
                self.set_df_project(df_p)
                # Get the indices of the new rows, as they are in df_p
                uistate.list_idx_recs2preload = df_p.index[
                    df_p.index >= len(df_p) - len(rows2add)
                ].tolist()
        self.progressBarManager.__exit__(None, None, None)
        print("onParseDataFinished: calling graphPreload")
        self.graphPreload()

    def flipCI(self):
        # Inverse Control/Intervention flags of currently selected and paired recordings
        if uistate.list_idx_select_recs:
            df_p = self.get_df_project()
            already_flipped = []
            for index in uistate.list_idx_select_recs:
                row = df_p.loc[index]
                name_rec = row["recording_name"]
                name_pair = row["paired_recording"]
                index_pair = df_p[df_p["recording_name"] == name_pair].index[0]
                if index in already_flipped:
                    print(f"Already flipped {index}")
                    continue
                # if row_pair doesn't exist:
                if pd.isna(name_pair):
                    print(f"{name_rec} has no paired recording.")
                    return
                print(f"Flipping C-I for {name_rec} and {name_pair}...")
                df_p.at[index, "Tx"] = not df_p.at[index, "Tx"]
                df_p.at[index_pair, "Tx"] = not df_p.at[index, "Tx"]
                # clear caches and diff files
                key_pair = name_rec[:-2]
                self.dict_diffs.pop(key_pair, None)
                path_diff = Path(
                    f"{self.dict_folders['cache']}/{key_pair}_diff.parquet"
                )
                if path_diff.exists():
                    path_diff.unlink()
                # TODO: clear group cache
                already_flipped.append(index_pair)
                self.set_df_project(df_p)
                self.tableUpdate()
            self.mouseoverUpdate()
        else:
            print("No files selected.")

    # Data Group handling functions → GroupMixin (ui_groups.py)
    # Writer / project functions → ProjectMixin (ui_project.py)

    def set_rec_status(self, rec_name=None):  # TODO: should run on ID - not name!
        # Updates df_project['status'] to 'manual' if there is a single manual point, else 'default' if there is a default point, else 'auto'
        # TODO: expand this to cover more issues with recordings and specify algorithm used.
        def status(rec_name, dfp, marker_list):
            prow = dfp[dfp["recording_name"] == rec_name]
            if isinstance(prow, pd.DataFrame):
                p_series = prow.iloc[0]
            else:
                p_series = prow
            dft = self.get_dft(p_series)
            for marker in marker_list:
                if marker in dft.values:
                    dfp.loc[dfp["recording_name"] == rec_name, "status"] = marker
                    logger.debug(
                        "set_rec_status: %s set to status = '%s'", rec_name, marker
                    )
                    print(f"set_rec_status: {rec_name} set to status = '{marker}'")
                    return
            dfp.loc[dfp["recording_name"] == rec_name, "status"] = "auto"
            return

        # in order of priority, look for these markers in the timepoints dataframe
        marker_list = ["manual", "default"]
        dfp = self.get_df_project()

        if rec_name is not None:
            status(rec_name, dfp, marker_list)
        else:
            for i, row in dfp.iterrows():
                status(row["recording_name"], dfp, marker_list)

        self.set_df_project(dfp)
        # tableUpdate() touches Qt widgets and must only run on the GUI thread.
        # Worker threads (e.g. graphPreloadThread) call set_rec_status too, so
        # guard the call to avoid a cross-thread Qt deadlock.
        if QtCore.QThread.currentThread() is QtWidgets.QApplication.instance().thread():
            self.tableUpdate()

    # set_dft → DataFrameMixin (ui_data_frames.py)

    # Table handling

    def setButtonParse(self):
        logger.debug("setButtonParse")
        print("setButtonParse")
        unparsed = self.df_project["sweeps"].eq("...").any()
        self.pushButtonParse.setVisible(bool(unparsed))
        self.frameParseOptions.setVisible(bool(unparsed))

    def checkBox_splitOddEven_changed(self, state):
        uistate.checkBox["splitOddEven"] = state == 2
        logger.debug("checkBox_splitOddEven_changed: %s", state)
        print(f"checkBox_splitOddEven_changed: {state}")

    def checkBox_output_per_stim_changed(self, state):
        uistate.checkBox["output_per_stim"] = state == 2
        print(f"checkBox_output_per_stim_changed: {state}")
        self.uiFreeze()
        df_p = self.get_df_project()
        for i, p_row in df_p.iterrows():
            dfoutput = self.get_dfoutput(p_row, reset=True)
            self.persistOutput(p_row["recording_name"], dfoutput)
            uiplot.unPlot(p_row["ID"])
            df_t = self.get_dft(p_row)
            dfmean = self.get_dfmean(p_row)
            uiplot.addRow(p_row=p_row, dft=df_t, dfmean=dfmean, dfoutput=dfoutput)
            self.update_show(reset=True)
        self.uiThaw()
        self.zoomAuto()

    def checkBox_timepoints_per_stim_changed(self, state):
        uistate.checkBox["timepoints_per_stim"] = state == 2
        print(f"checkBox_timepoints_per_stim_changed: {state}")
        if state == 0:
            self.set_uniformTimepoints()

    def checkBox_bin_changed(self, state):
        uistate.checkBox["bin"] = state == 2
        print(f"checkBox_bin_changed: {state}")
        if state == 2:
            self.binSweeps()

    def tableFormat(self):
        logger.debug("tableFormat")
        print("tableFormat")
        selected_rows = self.tableProj.selectionModel().selectedRows()
        # Update data
        self.tablemodel.setData(self.get_df_project())
        # Restore selection
        selection = QtCore.QItemSelection()
        for index in selected_rows:
            selection.select(index, index)
        self.tableProj.selectionModel().select(
            selection,
            QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Rows,
        )
        self.setButtonParse()

    def tableUpdate(self):
        self.updating_tableProj = True  # prevent tableProjSelectionChanged from firing
        # Update data
        df_project = self.get_df_project()
        self.tablemodel.setData(df_project)
        self.tableProj.resizeColumnsToContents()
        # Restore selection
        selection_model = self.tableProj.selectionModel()
        for idx in uistate.list_idx_select_recs:
            index = self.tablemodel.index(idx, 0)  # get the QModelIndex for the row
            selection_model.select(
                index,
                QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Rows,
            )
            # print(f"tableUpdate: reselecting {len(uistate.list_idx_select_recs)}: {idx}")
        self.updating_tableProj = False

    # Internal dataframe handling
    def get_prow(self, dfp_idx=None):
        # returns the selected row with the lowest index in df_project
        if dfp_idx is not None:
            dfp = self.get_df_project()
            row = dfp.loc[dfp_idx]
            return row
        if not uistate.list_idx_select_recs:
            print("get_prow: No recording selected.")
            return None
        dfp = self.get_df_project()
        row = dfp.loc[uistate.list_idx_select_recs[0]]
        return row

    def get_trow(self, dfp_idx=None):
        if dfp_idx is not None:
            dft = self.get_dft(self.get_prow(dfp_idx))
        else:
            if not uistate.list_idx_select_stims:
                print("get_trow: No stim selected.")
                return None
            dft = self.get_dft(self.get_prow())
        if dft is None or len(dft) == 0:
            print("get_trow: Empty dataframe.")
            return None
        # ensure index is valid
        idx = uistate.list_idx_select_stims[0] if uistate.list_idx_select_stims else 0
        if idx < 0 or idx >= len(dft):
            idx = 0
            uistate.list_idx_select_stims = [0]
        return dft.loc[idx]

    # get_dfmean, get_dft, get_dfoutput, get_dfdata, get_dffilter, get_dfbin,
    # get_dfdiff, get_dfgroupmean, set_uniformTimepoints → DataFrameMixin (ui_data_frames.py)

    # Graph interface

    def graphWipe(self):  # removes all plots from canvasEvent and canvasOutput
        uistate.dict_rec_labels = {}
        uistate.dict_rec_show = {}
        uistate.dict_group_labels = {}
        uistate.dict_group_show = {}
        if hasattr(self, "canvasMean"):
            self.canvasMean.figure.legends.clear()
            self.canvasMean.axes.cla()
            self.canvasMean.draw()
        if hasattr(self, "canvasEvent"):
            self.canvasEvent.figure.legends.clear()
            self.canvasEvent.axes.cla()
            self.canvasEvent.draw()
        if hasattr(self, "canvasOutput"):
            for ax in self.canvasOutput.figure.axes:
                ax.cla()
                ax.legend_ = None
            self.canvasOutput.draw()

    def graphAxes(self):  # plot selected row(s), or clear graph if empty
        print("graphAxes")
        uistate.axm = self.canvasMean.axes
        uistate.axe = self.canvasEvent.axes
        ax1 = self.canvasOutput.axes
        if uistate.ax2 is not None and hasattr(
            uistate, "ax2"
        ):  # remove ax2 if it exists
            uistate.ax2.remove()
        ax2 = ax1.twinx()
        uistate.ax2 = ax2  # Store the ax2 instance
        uistate.ax1 = ax1
        # connect scroll event if not already connected #TODO: when graphAxes is called only once, the check should be redundant
        if (
            not hasattr(self, "scroll_event_connected")
            or not self.scroll_event_connected
        ):
            self.canvasMean.mpl_connect(
                "scroll_event",
                lambda event: self.zoomOnScroll(event=event, graph="mean"),
            )
            self.canvasEvent.mpl_connect(
                "scroll_event",
                lambda event: self.zoomOnScroll(event=event, graph="event"),
            )
            self.canvasOutput.mpl_connect(
                "scroll_event",
                lambda event: self.zoomOnScroll(event=event, graph="output"),
            )
            self.scroll_event_connected = True
        df_p = self.get_df_project()
        if df_p.empty:
            return
        self.graphPreload()

    def graphPreload(self):  # plot and hide imported recordings
        print("graphPreload: entered")
        self.usage("graphPreload")
        self.uiFreeze()  # Freeze UI, thaw on graphPreloadFinished
        t0 = time.time()
        self.mouseoverDisconnect()
        # Clean up any existing thread before starting a new one
        self._cleanup_threads()
        if not uistate.list_idx_recs2preload:
            print(
                "graphPreload: list_idx_recs2preload empty, falling back to all parsed recordings"
            )
            df_p = self.get_df_project()
            uistate.list_idx_recs2preload = df_p[
                ~df_p["sweeps"].eq("...")
            ].index.tolist()
        if not uistate.list_idx_recs2preload:
            print("graphPreload: nothing to preload, returning early")
            self.uiThaw()
            return
        print(
            f"graphPreload: starting thread for {len(uistate.list_idx_recs2preload)} recordings: {uistate.list_idx_recs2preload}"
        )
        self.progressBar.setValue(0)
        thread = graphPreloadThread(uistate, uiplot, self)
        thread.finished.connect(lambda: self.ongraphPreloadFinished(t0))
        thread.finished.connect(thread.deleteLater)  # Auto-cleanup when done
        thread.finished.connect(
            lambda: self._threads.remove(thread) if thread in self._threads else None
        )
        self._threads.append(thread)

        # Create ProgressBarManager and connect progress signal
        if len(uistate.list_idx_recs2preload) > 0:
            self.progressBarManager = ProgressBarManager(
                self.progressBar, len(uistate.list_idx_recs2preload)
            )
            thread.progress.connect(
                lambda i: self.progressBarManager.update(i, "Preloading recording")
            )

            thread.start()
            self.progressBarManager.__enter__()  # Show progress bar
        else:
            print("No new recordings to preload.")

    def ongraphPreloadFinished(self, t0):
        self.graphGroups()
        print(f"Preloaded recordings and groups in {time.time() - t0:.2f} seconds.")
        self.graphRefresh()
        self.progressBarManager.__exit__(None, None, None)  # Hide progress bar
        self.tableFormat()
        self.uiThaw()
        self.tableProjSelectionChanged()

    def graphGroups(self):
        # Get all group IDs
        if not self.dd_groups:
            return
        all_group_ids = set(self.dd_groups.keys())
        if not all_group_ids:
            return
        groups_with_records = {
            group_id: group_info
            for group_id, group_info in self.dd_groups.items()
            if group_info["rec_IDs"]
        }
        already_plotted_groups = set(uistate.get_groupSet())
        groups_to_plot = (
            all_group_ids & set(groups_with_records.keys()) - already_plotted_groups
        )
        if groups_to_plot:
            for group_ID in groups_to_plot:
                dict_group = self.dd_groups[group_ID]
                group_mean_data = self.get_dfgroupmean(group_ID)
                # print(f"graphGroups: Adding group {group_ID} to plot: {group_mean_data}")
                uiplot.addGroup(group_ID, dict_group, group_mean_data)

    def graphUpdate(self, df=None, row=None):
        def processRow(row):
            dfmean = self.get_dfmean(row=row)
            dft = self.get_dft(row=row)
            print(f"graphUpdate dft: {dft}")
            dfoutput = (
                self.get_dfdiff(row=row)
                if uistate.checkBox["paired_stims"]
                else self.get_dfoutput(row=row)
            )
            if dfoutput is not None:
                uiplot.addRow(p_row=row, dft=dft, dfmean=dfmean, dfoutput=dfoutput)

        def processDataFrame(df):
            list_to_plot = [
                rec
                for rec in df["recording_name"].tolist()
                if rec not in uistate.get_recSet()
            ]
            for rec in list_to_plot:
                row = df[df["recording_name"] == rec].iloc[0]
                processRow(row)

        self.graphGroups()
        if row is not None:
            processRow(row)
        else:
            df = df or uistate.df_recs2plot
            if df is not None and not df.empty:
                processDataFrame(df)
        self.zoomAuto()
        print("graphUpdate calls self.graphRefresh()")
        self.graphRefresh()

    #####################################################
    #          Mouseover, click and drag events         #
    #####################################################

    def graphClicked(self, event, canvas):  # graph click event
        if not uistate.list_idx_select_recs:  # no recording selected; do nothing
            return
        x = event.xdata
        if x is None:  # clicked outside graph; do nothing
            return
        self.usage("graphClicked")
        if event.button == 2:  # middle click, reset zoom
            # print(f"axis: {axis}, type {type(axis)}")
            self.zoomAuto()
            return
        if event.button == 3:  # right click, deselect
            if uistate.dragging:
                return
            self.mouse_drag = None
            self.mouse_release = None
            uistate.x_drag = None
            if canvas == self.canvasMean:
                uiplot.xDeselect(ax=uistate.axm, reset=True)
                self.lineEdit_mean_selection_start.setText("")
                self.lineEdit_mean_selection_end.setText("")
            else:
                uiplot.xDeselect(ax=uistate.ax1, reset=True)
                self.lineEdit_sweeps_range_from.setText("")
                self.lineEdit_sweeps_range_to.setText("")
            return

        # left clicked on a graph
        uistate.dragging = True
        prow = self.get_prow()

        if (
            (canvas == self.canvasEvent)
            and (len(uistate.list_idx_select_recs) == 1)
            and (len(uistate.list_idx_select_stims) == 1)
        ):  # Event canvas left-clicked with just one rec and stim selected, middle graph: editing detected events
            uistate.dft_temp = self.get_dft(prow).copy()
            trow = uistate.dft_temp.loc[uistate.list_idx_select_stims[0]]
            label = f"{prow['recording_name']} - stim {trow['stim']}"
            dict_event = uistate.dict_rec_labels[label]
            data_x = dict_event["line"].get_xdata()
            data_y = dict_event["line"].get_ydata()
            uistate.x_on_click = data_x[
                np.abs(data_x - x).argmin()
            ]  # time-value of the nearest index
            # print(f"uistate.x_on_click: {uistate.x_on_click}")
            if event.inaxes is not None:
                if (event.button == 1 or event.button == 3) and (
                    uistate.mouseover_action is not None
                ):
                    action = uistate.mouseover_action
                    # print(f"mouseover action: {action}")
                    if action.startswith("EPSP slope"):
                        start, end = (
                            trow["t_EPSP_slope_start"] - trow["t_stim"],
                            trow["t_EPSP_slope_end"] - trow["t_stim"],
                        )
                        self.mouse_drag = self.canvasEvent.mpl_connect(
                            "motion_notify_event",
                            lambda event: self.eventDragSlope(
                                event, action, data_x, data_y, start, end
                            ),
                        )
                    elif action == "EPSP amp move":
                        start = trow["t_EPSP_amp"] - trow["t_stim"]
                        self.mouse_drag = self.canvasEvent.mpl_connect(
                            "motion_notify_event",
                            lambda event: self.eventDragPoint(
                                event, data_x, data_y, start
                            ),
                        )
                    elif action.startswith("volley slope"):
                        start, end = (
                            trow["t_volley_slope_start"] - trow["t_stim"],
                            trow["t_volley_slope_end"] - trow["t_stim"],
                        )
                        self.mouse_drag = self.canvasEvent.mpl_connect(
                            "motion_notify_event",
                            lambda event: self.eventDragSlope(
                                event, action, data_x, data_y, start, end
                            ),
                        )
                    elif action == "volley amp move":
                        start = trow["t_volley_amp"] - trow["t_stim"]
                        self.mouse_drag = self.canvasEvent.mpl_connect(
                            "motion_notify_event",
                            lambda event: self.eventDragPoint(
                                event, data_x, data_y, start
                            ),
                        )
                    self.mouse_release = self.canvasEvent.mpl_connect(
                        "button_release_event",
                        lambda event: self.eventDragReleased(event, data_x, data_y),
                    )

        elif (
            canvas == self.canvasMean
        ):  # Mean canvas (top graph) left-clicked: overview and selecting ranges for finding relevant stims
            if uistate.mean_mouseover_stim_select is not None:
                uistate.dragging = False
                self.stimSelectionChanged()
                return
            dfmean = self.get_dfmean(prow)  # Required for event dragging, x and y
            time_values = dfmean["time"].values
            uistate.x_on_click = time_values[np.abs(time_values - x).argmin()]
            uistate.x_select["mean_start"] = uistate.x_on_click
            self.lineEdit_mean_selection_start.setText(
                f"{uistate.x_select['mean_start'] * 1000:g}"
            )
            self.connectDragRelease(
                x_range=time_values, rec_ID=prow["ID"], graph="mean"
            )
        elif (
            canvas == self.canvasOutput
        ):  # Output canvas (bottom graph) left-clicked: click and drag to select specific sweeps
            sweep_numbers = list(range(0, int(prow["sweeps"])))
            uistate.x_on_click = sweep_numbers[np.abs(sweep_numbers - x).argmin()]
            uistate.x_select["output_start"] = uistate.x_on_click
            self.lineEdit_sweeps_range_from.setText(str(uistate.x_on_click))
            self.connectDragRelease(
                x_range=sweep_numbers, rec_ID=prow["ID"], graph="output"
            )

    def meanMouseover(self, event):  # determine which event is being mouseovered
        x = event.xdata
        y = event.ydata
        if x is None or y is None:
            return
        dft = uistate.df_rec_select_time
        if dft is None or dft.empty:
            # print("No single recording selected with timepoints to mouseover.")
            return
        n_stims = len(dft)
        if n_stims < 2:
            # print("Not enough stims to mouseover.")
            return
        # One recording selected, with 2 or more stims, define mouseover zones
        prow = self.get_prow()
        rec_name = f"{prow['recording_name']}"
        rec_filter = prow["filter"]  # the filter currently used for this recording
        if rec_filter != "voltage":
            label_core = f"{rec_name} ({rec_filter})"
        else:
            label_core = rec_name

        axm = uistate.axm
        uistate.mean_mouseover_stim_select = (
            None  # name of stim that will be selected if clicked
        )
        uistate.mean_stim_x_ranges = {}  # dict: stim_num: (x_start, x_end)
        # y_margin is 10% of y-axis range
        uistate.mean_y_margin = (axm.get_ylim()[1] - axm.get_ylim()[0]) * 0.1
        y_range = (
            -uistate.mean_y_margin,
            uistate.mean_y_margin,
        )  # stim markers should be at y~0
        # x_margin is 25% of the shortest distance between stims OR 1% of x-axis range, whichever is smaller
        t_stims = dft["t_stim"].values
        t_diffs = np.diff(t_stims)
        min_t_diff = np.min(t_diffs)
        x_axis_range = axm.get_xlim()[1] - axm.get_xlim()[0]
        uistate.mean_x_margin = min(x_axis_range * 0.01, min_t_diff * 0.25)

        # build detection zones for each stim
        for row in dft.itertuples(index=False):
            stim = row.stim
            t_stim = row.t_stim
            x_range = t_stim - uistate.mean_x_margin, t_stim + uistate.mean_x_margin
            uistate.mean_stim_x_ranges[stim] = x_range
        # check if mouse is within any of the stim zones
        for stim, x_range in uistate.mean_stim_x_ranges.items():
            if x_range[0] <= x <= x_range[1] and y_range[0] <= y <= y_range[1]:
                uistate.mean_mouseover_stim_select = stim
                # print(f"meanMouseover of {uistate.mean_mouseover_stim_select}: x={x}, y={y}")
                # find corresponding selection marker:
                stim_str = f"- stim {stim}"
                label = f"mean {label_core} {stim_str} marker"
                stim_marker = uistate.dict_rec_labels.get(label)
                # print(f"{label}: {stim_marker}")
                # zorder mouseovered marker to top, alpha 1
                if stim_marker is not None:
                    stim_marker_line = stim_marker.get("line")
                    stim_marker_line.set_zorder(10)
                    stim_marker_line.set_alpha(1.0)
                break
            else:
                # reset all stim markers to default zorder and alpha
                stim_str = f"- stim {stim}"
                label = f"mean {label_core} {stim_str} marker"
                stim_marker = uistate.dict_rec_labels.get(label)
                if stim_marker is not None:
                    stim_marker_line = stim_marker.get("line")
                    stim_marker_line.set_zorder(0)
                    stim_marker_line.set_alpha(0.4)

        axm.figure.canvas.draw()

    def eventMouseover(self, event):  # determine which event is being mouseovered
        if (
            uistate.df_rec_select_data is None
        ):  # no single recording/stim combo selected
            return
        axe = uistate.axe

        def plotMouseover(action, axe):
            alpha = 0.8
            linewidth = 3 if "resize" in action else 10
            if "slope" in action:
                if "EPSP" in action:
                    x_range = (
                        uistate.EPSP_slope_start_xy[0],
                        uistate.EPSP_slope_end_xy[0],
                    )
                    y_range = (
                        uistate.EPSP_slope_start_xy[1],
                        uistate.EPSP_slope_end_xy[1],
                    )
                    color = uistate.settings["rgb_EPSP_slope"]
                elif "volley" in action:
                    x_range = (
                        uistate.volley_slope_start_xy[0],
                        uistate.volley_slope_end_xy[0],
                    )
                    y_range = (
                        uistate.volley_slope_start_xy[1],
                        uistate.volley_slope_end_xy[1],
                    )
                    color = uistate.settings["rgb_volley_slope"]

                if uistate.mouseover_blob is None:
                    uistate.mouseover_blob = axe.scatter(
                        x_range[1], y_range[1], color=color, s=100, alpha=alpha
                    )
                else:
                    uistate.mouseover_blob.set_offsets([x_range[1], y_range[1]])
                    uistate.mouseover_blob.set_sizes([100])
                    uistate.mouseover_blob.set_color(color)

                if uistate.mouseover_plot is None:
                    uistate.mouseover_plot = axe.plot(
                        x_range,
                        y_range,
                        color=color,
                        linewidth=linewidth,
                        alpha=alpha,
                        label="mouseover",
                    )
                else:
                    uistate.mouseover_plot[0].set_data(x_range, y_range)
                    uistate.mouseover_plot[0].set_linewidth(linewidth)
                    uistate.mouseover_plot[0].set_alpha(alpha)
                    uistate.mouseover_plot[0].set_color(color)

            elif "amp" in action:
                if "EPSP" in action:
                    x, y = uistate.EPSP_amp_xy
                    color = uistate.settings["rgb_EPSP_amp"]
                elif "volley" in action:
                    x, y = uistate.volley_amp_xy
                    color = uistate.settings["rgb_volley_amp"]

                if uistate.mouseover_blob is None:
                    uistate.mouseover_blob = axe.scatter(
                        x, y, color=color, s=100, alpha=alpha
                    )
                else:
                    uistate.mouseover_blob.set_offsets([x, y])
                    uistate.mouseover_blob.set_sizes([100])
                    uistate.mouseover_blob.set_color(color)

        x = event.xdata
        y = event.ydata
        if x is None or y is None:
            return
        if event.inaxes == axe:
            zones = {}
            if uistate.checkBox["EPSP_amp"]:
                zones["EPSP amp move"] = uistate.EPSP_amp_move_zone
            if uistate.checkBox["EPSP_slope"]:
                zones["EPSP slope resize"] = uistate.EPSP_slope_resize_zone
                zones["EPSP slope move"] = uistate.EPSP_slope_move_zone
            if uistate.checkBox["volley_amp"]:
                zones["volley amp move"] = uistate.volley_amp_move_zone
            if uistate.checkBox["volley_slope"]:
                zones["volley slope resize"] = uistate.volley_slope_resize_zone
                zones["volley slope move"] = uistate.volley_slope_move_zone
            uistate.mouseover_action = None
            for action, zone in zones.items():
                if (
                    zone["x"][0] <= x <= zone["x"][1]
                    and zone["y"][0] <= y <= zone["y"][1]
                ):
                    uistate.mouseover_action = action
                    plotMouseover(action, axe)

                    # Debugging block
                    if False:
                        prow = self.get_prow()
                        rec_name = prow["recording_name"]
                        rec_ID = prow["ID"]
                        trow = self.get_trow()
                        # new_dict = {key: value for key, value in uistate.dict_rec_labels.items() if value.get('stim') == stim_num and value.get('rec_ID') == rec_ID and value.get('axis') == 'ax2'}
                        # EPSP_slope = new_dict.get(f"{rec_name} - stim {stim_num} EPSP slope")
                        EPSP_slope = uistate.dict_rec_labels.get(
                            f"{rec_name} - stim {trow['stim']} EPSP slope"
                        )
                        line = EPSP_slope.get("line")
                        line.set_linewidth(10)
                        print(f"{EPSP_slope} - {action}")
                    break

            if uistate.mouseover_action is None:
                if uistate.mouseover_blob is not None:
                    uistate.mouseover_blob.set_sizes([0])
                if uistate.mouseover_plot is not None:
                    uistate.mouseover_plot[0].set_linewidth(0)

            axe.figure.canvas.draw()

    def outputMouseover(self, event):  # determine which event is being mouseovered
        x, y = event.xdata, event.ydata
        str_ax = "ax2" if uistate.slopeView() else "ax1" if uistate.ampView() else None
        ax = getattr(uistate, str_ax)
        print(f"outputMouseover: x={x}, y={y}, str_ax={str_ax}")
        if (
            str_ax is None
            or x is None
            or y is None
            or not event.inaxes == ax
            or not (uistate.slopeView() or uistate.ampView())
        ):
            if (
                uistate.ghost_sweep is not None
            ):  # remove ghost sweep if outside output graph
                self.exorcise()
            return
        if len(uistate.list_idx_select_recs) != 1:
            self.exorcise()
            return
        x_axis = "stim" if uistate.checkBox["output_per_stim"] else "sweep"

        # find a visible line
        dict_out = {
            key: value
            for key, value in uistate.dict_rec_show.items()
            if value["axis"] == str_ax
            and (value["aspect"] in ["EPSP_amp", "EPSP_slope"])
        }
        if not dict_out:
            return
        dict_pop = dict_out.popitem()[1]  # TODO: ugly random; pick top in df_p?
        x_data = dict_pop["line"].get_xdata()
        # find closest x_index
        out_x_idx = (np.abs(x_data - x)).argmin()

        # print(f"* * * outputMouseover: out_x_idx={out_x_idx}, sweeps={sweeps}")

        if out_x_idx == uistate.last_out_x_idx:  # prevent update if same x
            return

        if x_axis == "stim":  # Not connected yet
            return
        else:  # sweep
            rec_ID = dict_pop["rec_ID"]
            df_p = self.get_df_project()
            p_row = df_p[df_p["ID"] == rec_ID].iloc[0]
            df_t = self.get_dft(p_row)
            stim = dict_pop["stim"]
            t_row = df_t[df_t["stim"] == stim].iloc[0]
            offset = t_row["t_stim"]

            if uistate.checkBox["bin"]:
                dfsource = self.get_dfbin(p_row)
            else:
                dfsource = self.get_dffilter(p_row)

            dfsweep = dfsource[
                dfsource["sweep"] == out_x_idx
            ]  # select only rows where sweep == out_x_idx
            sweep_x = dfsweep["time"] - offset
            sweep_y = dfsweep[
                p_row["filter"]
            ]  # get the value of the filter at the selected sweep

            if uistate.ghost_sweep is None:
                ghost_color = "white" if uistate.darkmode else "black"
                (uistate.ghost_sweep,) = uistate.axe.plot(
                    sweep_x, sweep_y, color=ghost_color, alpha=0.5, zorder=0
                )
                if uistate.ghost_label is None:
                    uistate.ghost_label = uistate.axe.text(
                        1,
                        1,
                        f"sweep {out_x_idx}",
                        transform=uistate.axe.transAxes,
                        ha="left",
                        va="bottom",
                    )
                else:
                    uistate.ghost_label.set_text(f"sweep {out_x_idx}")
            else:
                uistate.ghost_sweep.set_data(sweep_x, sweep_y)
                uistate.ghost_label.set_text(f"sweep {out_x_idx}")
            uistate.axe.figure.canvas.draw()
        uistate.last_out_x_idx = out_x_idx
        ax.figure.canvas.draw()

    def on_leave_output(self, event):
        self.exorcise()

    def exorcise(self):
        if uistate.ghost_sweep is not None:
            uistate.ghost_sweep.remove()
            uistate.ghost_sweep = None
        if uistate.ghost_label is not None:
            uistate.ghost_label.remove()
            uistate.ghost_label = None
        uistate.axe.figure.canvas.draw()

    def connectDragRelease(self, x_range, rec_ID, graph):
        self.usage("connectDragRelease")
        # function to set up x scales for dragging and releasing on mean- and output canvases
        if graph == "mean":  # uistate.axm
            canvas = self.canvasMean
            filtered_values = [
                value["line"]
                for value in uistate.dict_rec_labels.values()
                if value["rec_ID"] == rec_ID and value["axis"] == "axm"
            ]
        elif graph == "output":  # uistate.ax1+ax2
            canvas = self.canvasOutput
            filtered_values = [
                value["line"]
                for value in uistate.dict_rec_labels.values()
                if value["rec_ID"] == rec_ID
                and (value["axis"] == "ax1" or value["axis"] == "ax2")
            ]
        else:
            print("connectDragRelease: Incorrect graph reference.")
            return

        filtered_values = [
            line for line in filtered_values if len(line.get_xdata()) > 0
        ]
        max_x_line = max(
            filtered_values, key=lambda line: line.get_xdata()[-1], default=None
        )
        if max_x_line is None:
            print("No lines found. Cannot set up drag and release.")
            return
        x_data = max_x_line.get_xdata()
        self.mouse_drag = canvas.mpl_connect(
            "motion_notify_event",
            lambda event: self.xDrag(
                event, canvas=canvas, x_data=x_data, x_range=x_range
            ),
        )
        self.mouse_release = canvas.mpl_connect(
            "button_release_event",
            lambda event: self.drag_released(event, canvas=canvas),
        )

    def xDrag(self, event, canvas, x_data, x_range):
        # self.usage("xDrag")
        if not uistate.dragging:
            return
        if event.xdata is None:
            return
        x = event.xdata  # mouse x position
        x_drag = np.abs(x_data - x).argmin()  # index closest to x
        if (
            x_drag == uistate.x_drag_last
        ):  # return if the pointer hasn't moved a full idx since last update
            return
        if x_drag < 0:
            x_drag = 0
        elif x_drag >= len(x_data):
            x_drag = len(x_data) - 1
        uistate.x_drag = x_range[np.abs(x_range - x).argmin()]
        uistate.x_drag_last = uistate.x_drag
        if canvas == self.canvasMean:
            uistate.x_select["mean_end"] = uistate.x_drag
            self.lineEdit_mean_selection_end.setText(f"{uistate.x_drag * 1000:g}")
        else:
            uistate.x_select["output_end"] = uistate.x_drag
            uistate.x_select["output"] = set(
                range(
                    min(uistate.x_on_click, uistate.x_drag),
                    max(uistate.x_on_click, uistate.x_drag) + 1,
                )
            )
            # print(f"uistate.x_select['output']: {uistate.x_select['output']}")
        uiplot.xSelect(canvas=canvas)

    def drag_released(self, event, canvas):
        self.usage("drag_released")
        is_mean = canvas is self.canvasMean
        is_output = canvas is self.canvasOutput

        if uistate.x_drag is None:  # click only
            if is_mean:
                self.lineEdit_mean_selection_end.setText("")
                uistate.x_select["mean_end"] = None
                self.lineEdit_mean_selection_start.setText(
                    f"{uistate.x_select['mean_start'] * 1000:g}"
                )
            elif is_output:
                self.lineEdit_sweeps_range_to.setText("")
                uistate.x_select["output_end"] = None
                uistate.x_select["output"] = {uistate.x_on_click}  # ensure set type
                uiplot.update_axe_mean()
        else:  # click and drag
            start, end = sorted((uistate.x_on_click, uistate.x_drag))
            if is_mean:
                uistate.x_select["mean_start"] = start
                uistate.x_select["mean_end"] = end
                self.lineEdit_mean_selection_start.setText(f"{start * 1000:g}")
                self.lineEdit_mean_selection_end.setText(f"{end * 1000:g}")
            elif is_output:
                uistate.x_select["output_start"] = start
                uistate.x_select["output_end"] = end
                uistate.x_select["output"] = set(range(start, end + 1))
                self.lineEdit_sweeps_range_from.setText(str(start))
                self.lineEdit_sweeps_range_to.setText(str(end))
                uiplot.update_axe_mean()
        # cleanup
        canvas.mpl_disconnect(self.mouse_drag)
        canvas.mpl_disconnect(self.mouse_release)
        self.mouse_drag = None
        self.mouse_release = None
        uistate.x_drag = None
        uistate.dragging = False

        uiplot.xSelect(canvas=canvas)

    def mouseoverUpdate(self):
        self.usage("mouseoverUpdate")
        self.mouseoverDisconnect()
        # if only one item is selected, make a new mouseover event connection
        if uistate.list_idx_select_recs and uistate.list_idx_select_stims:
            self.mouseoverUpdateMarkers()

        if len(uistate.list_idx_select_recs) != 1:
            print("(multi-rec-selection) mouseoverUpdate calls self.graphRefresh()")
            self.graphRefresh()
            return
        if len(uistate.list_idx_select_stims) != 1:
            print("(multi-stim-selection) mouseoverUpdate calls self.graphRefresh()")
            self.graphRefresh()
            return
        # print(f"mouseoverUpdate: {uistate.list_idx_select_recs[0]}, {type(uistate.list_idx_select_recs[0])}")
        prow = self.get_prow()
        if prow is None:
            logger.debug(
                "mouseoverUpdate: prow is None, calling graphRefresh and returning"
            )
            self.graphRefresh()
            return
        rec_ID = prow["ID"]
        trow = self.get_trow()
        if trow is None:
            logger.debug(
                "mouseoverUpdate: trow is None, calling graphRefresh and returning"
            )
            self.graphRefresh()
            return
        stim_num = trow["stim"]
        uistate.setMargins(axe=uistate.axe)
        dict_labels = {
            key: value
            for key, value in uistate.dict_rec_labels.items()
            if key.endswith(" marker")
            and value["rec_ID"] == rec_ID
            and value["axis"] == "axe"
            and value["stim"] == stim_num
        }
        if not dict_labels:
            print("(no labels) mouseoverUpdate calls self.graphRefresh()")
            self.graphRefresh()
            return

        for label, value in dict_labels.items():
            line = value["line"]
            if label.endswith("EPSP amp marker"):
                uistate.updatePointDragZone(
                    aspect="EPSP amp move", x=line.get_xdata()[0], y=line.get_ydata()[0]
                )
            elif label.endswith("volley amp marker"):
                uistate.updatePointDragZone(
                    aspect="volley amp move",
                    x=line.get_xdata()[0],
                    y=line.get_ydata()[0],
                )
            elif label.endswith("EPSP slope marker"):
                uistate.updateDragZones(
                    aspect="EPSP slope", x=line.get_xdata(), y=line.get_ydata()
                )
            elif label.endswith("volley slope marker"):
                uistate.updateDragZones(
                    aspect="volley slope", x=line.get_xdata(), y=line.get_ydata()
                )

        self.mouseoverMean = self.canvasMean.mpl_connect(
            "motion_notify_event", self.meanMouseover
        )
        self.mouseoverEvent = self.canvasEvent.mpl_connect(
            "motion_notify_event", self.eventMouseover
        )
        self.mouseoverOutput = self.canvasOutput.mpl_connect(
            "motion_notify_event", self.outputMouseover
        )
        self.mouseLeaveOutput = self.canvasOutput.mpl_connect(
            "axes_leave_event", self.on_leave_output
        )
        # print("mouseoverUpdate calls self.graphRefresh()")
        self.graphRefresh()

    def mouseoverUpdateMarkers(self):
        self.usage("mouseoverUpdateMarkers")
        # update xy data of shown markers
        df_p = self.get_df_project()
        precision = uistate.settings["precision"]

        EPSP_slope_markers = {
            k: v
            for k, v in uistate.dict_rec_show.items()
            if k.endswith(" EPSP slope marker")
        }
        # print(f"mouseoverUpdateMarkers: {EPSP_slope_markers.keys()}")
        for marker in EPSP_slope_markers.values():
            p_row = df_p.loc[df_p["ID"] == marker["rec_ID"]].squeeze()
            dfmean = self.get_dfmean(row=p_row)
            df_t = self.get_dft(row=p_row)
            stim_num = marker["stim"]
            t_row = df_t.loc[df_t["stim"] == stim_num].squeeze()
            t_stim = round(t_row["t_stim"], precision)
            # x: location on dfmean['time'], for acquiring y-values
            x_start, x_end = (
                round(t_row["t_EPSP_slope_start"], precision),
                round(t_row["t_EPSP_slope_end"], precision),
            )
            # event_x: location on event graph, for drawing event markers
            if not analysis.valid(x_start, x_end):
                print(
                    "ERROR - EPSP_slope_markers: invalid x_start or x_end in mouseoverUpdateMarkers"
                )
                print(type(x_start), x_start)
                print(type(x_end), x_end)
                return
            event_x_start, event_x_end = (
                round(t_row["t_EPSP_slope_start"] - t_stim, precision),
                round(t_row["t_EPSP_slope_end"] - t_stim, precision),
            )
            y_start = dfmean.loc[(dfmean["time"] - x_start).abs().idxmin(), "voltage"]
            y_end = dfmean.loc[(dfmean["time"] - x_end).abs().idxmin(), "voltage"]
            marker["line"].set_data([event_x_start, event_x_end], [y_start, y_end])

        EPSP_amp_markers = {
            k: v
            for k, v in uistate.dict_rec_show.items()
            if k.endswith(" EPSP amp marker")
        }
        # print(f"mouseoverUpdateMarkers: {EPSP_amp_markers.keys()}")
        for marker in EPSP_amp_markers.values():
            p_row = df_p.loc[df_p["ID"] == marker["rec_ID"]].squeeze()
            dfmean = self.get_dfmean(row=p_row)
            df_t = self.get_dft(row=p_row)
            stim_num = marker["stim"]
            t_row = df_t.loc[df_t["stim"] == stim_num].squeeze()
            t_stim = round(t_row["t_stim"], precision)
            # x: location on dfmean['time'], for acquiring y-values
            x_start = round(t_row["t_EPSP_amp"], precision)
            # event_x: location on event graph, for drawing event markers
            if not analysis.valid(x_start):
                print(
                    "ERROR - EPSP_amp_markers: invalid x_start or x_end in mouseoverUpdateMarkers"
                )
                print(type(x_start), x_start)
                return
            event_x_start = round(t_row["t_EPSP_amp"] - t_stim, precision)
            y_start = dfmean.loc[(dfmean["time"] - x_start).abs().idxmin(), "voltage"]
            marker["line"].set_data([event_x_start, event_x_start], [y_start, y_start])

        volley_slope_markers = {
            k: v
            for k, v in uistate.dict_rec_show.items()
            if k.endswith(" volley slope marker")
        }
        # print(f"mouseoverUpdateMarkers: {volley_slope_markers.keys()}")
        for marker in volley_slope_markers.values():
            p_row = df_p.loc[df_p["ID"] == marker["rec_ID"]].squeeze()
            dfmean = self.get_dfmean(row=p_row)
            df_t = self.get_dft(row=p_row)
            stim_num = marker["stim"]
            t_row = df_t.loc[df_t["stim"] == stim_num].squeeze()
            t_stim = round(t_row["t_stim"], precision)
            # x: location on dfmean['time'], for acquiring y-values
            x_start, x_end = (
                round(t_row["t_volley_slope_start"], precision),
                round(t_row["t_volley_slope_end"], precision),
            )
            # event_x: location on event graph, for drawing event markers
            if not analysis.valid(x_start, x_end):
                print(
                    "ERROR - volley_slope_markers: invalid x_start or x_end in mouseoverUpdateMarkers"
                )
                print(type(x_start), x_start)
                print(type(x_end), x_end)
                return
            event_x_start, event_x_end = (
                round(t_row["t_volley_slope_start"] - t_stim, precision),
                round(t_row["t_volley_slope_end"] - t_stim, precision),
            )
            y_start = dfmean.loc[(dfmean["time"] - x_start).abs().idxmin(), "voltage"]
            y_end = dfmean.loc[(dfmean["time"] - x_end).abs().idxmin(), "voltage"]
            marker["line"].set_data([event_x_start, event_x_end], [y_start, y_end])

        volley_amp_markers = {
            k: v
            for k, v in uistate.dict_rec_show.items()
            if k.endswith(" volley amp marker")
        }
        # print(f"mouseoverUpdateMarkers: {volley_amp_markers.keys()}")
        for marker in volley_amp_markers.values():
            p_row = df_p.loc[df_p["ID"] == marker["rec_ID"]].squeeze()
            dfmean = self.get_dfmean(row=p_row)
            df_t = self.get_dft(row=p_row)
            stim_num = marker["stim"]
            t_row = df_t.loc[df_t["stim"] == stim_num].squeeze()
            t_stim = round(t_row["t_stim"], precision)
            # x: location on dfmean['time'], for acquiring y-values
            x_start = round(t_row["t_volley_amp"], precision)
            # event_x: location on event graph, for drawing event markers
            if not analysis.valid(x_start):
                print(
                    "ERROR - volley_amp_markers: invalid x_start or x_end in mouseoverUpdateMarkers"
                )
                print(type(x_start), x_start)
                return
            event_x_start = round(t_row["t_volley_amp"] - t_stim, precision)
            y_start = dfmean.loc[(dfmean["time"] - x_start).abs().idxmin(), "voltage"]
            marker["line"].set_data([event_x_start, event_x_start], [y_start, y_start])

    def mouseoverDisconnect(self):
        self.usage("mouseoverDisconnect")
        # drop any prior mouseover event connections and plots
        if hasattr(self, "mouseover"):
            self.canvasEvent.mpl_disconnect(self.mouseoverEvent)
            self.canvasOutput.mpl_disconnect(self.mouseoverOutput)
        if uistate.mouseover_plot is not None:
            uistate.mouseover_plot[0].remove()
            uistate.mouseover_plot = None
        if uistate.mouseover_blob is not None:
            uistate.mouseover_blob.remove()
            uistate.mouseover_blob = None
        if uistate.mouseover_out is not None:
            uistate.mouseover_out[0].remove()
            uistate.mouseover_out = None
        uistate.mouseover_action = None

    def eventDragSlope(
        self, event, action, data_x, data_y, prior_slope_start, prior_slope_end
    ):  # graph dragging event
        # self.usage("eventDragSlope")
        self.canvasEvent.mpl_disconnect(self.mouseoverEvent)
        if event.xdata is None or action is None:
            return
        x = event.xdata
        uistate.x_drag = data_x[
            np.abs(data_x - x).argmin()
        ]  # time-value of the nearest index
        if (
            uistate.x_drag == uistate.x_drag_last
        ):  # if the dragged event hasn't moved an index point, change nothing
            return
        precision = uistate.settings["precision"]
        time_diff = uistate.x_drag - uistate.x_on_click
        # get the x values of the slope
        blob = True  # only moving amplitudes and resizing slopes have a blob
        if action.endswith("resize"):
            x_start = prior_slope_start
        elif action.endswith("move"):
            x_start = round(prior_slope_start + time_diff, precision)
            blob = False
        x_end = round(prior_slope_end + time_diff, precision)
        # prevent resizing below 1 index - TODO: make it flip instead
        if x_end <= x_start:
            x_start_index = np.where(data_x == x_start)[0][0]
            x_end = data_x[x_start_index + 1]
        # get y values
        x_indices = np.searchsorted(data_x, [x_start, x_end])
        y_start, y_end = data_y[x_indices]
        # remember the last x index
        uistate.x_drag_last = uistate.x_drag
        # update the mouseover plot
        uistate.mouseover_plot[0].set_data([x_start, x_end], [y_start, y_end])
        if blob:
            uistate.mouseover_blob.set_offsets([x_end, y_end])
        self.canvasEvent.draw()
        self.eventDragUpdate(x_start, x_end, precision)

    def eventDragPoint(
        self, event, data_x, data_y, prior_amp
    ):  # maingraph dragging event
        # self.usage("eventDragPoint")
        self.canvasEvent.mpl_disconnect(self.mouseoverEvent)
        if event.xdata is None:
            return
        x = event.xdata
        uistate.x_drag = data_x[
            np.abs(data_x - x).argmin()
        ]  # time-value of the nearest index
        if (
            uistate.x_drag == uistate.x_drag_last
        ):  # if the dragged event hasn't moved an index point, change nothing
            return
        precision = uistate.settings["precision"]
        time_diff = uistate.x_drag - uistate.x_on_click
        x_point = round(prior_amp + time_diff, precision)
        idx = (np.abs(data_x - x_point)).argmin()
        y_point = data_y[idx]
        # print (f"x_point: {x_point}, y_point: {y_point}")
        # remember the last x index
        uistate.x_drag_last = uistate.x_drag
        # update the mouseover plot
        uistate.mouseover_blob.set_offsets([x_point, y_point])
        self.canvasEvent.draw()
        self.eventDragUpdate(x_point, x_point, precision)

    def eventDragUpdate(self, x_start, x_end, precision):
        # TODO: Overhaul this whole magic-string-mess
        """
        Updates output graph uistate.mouseover_out while dragging event markers
        x_start: new start time of slope or amplitude
        x_end: new end time of slope (same as x_start for amplitude)
        precision: number of decimal places to round to
        * updates uistate.dft_temp in place: overwrites dft on release
        * builds a dict_t and feeds it to analysis.build_dfoutput
        * updates uistate.mouseover_out plot data
        TODO: fix for dfstimoutput
        """

        # self.usage("eventDragUpdate")
        def handle_slope(aspect, x_start, x_end, precision, stim_offset):
            slope_width = round(x_end - x_start, precision)
            slope_start_key = f"t_{aspect}_start"
            slope_end_key = f"t_{aspect}_end"
            slope_width_key = f"t_{aspect}_width"
            return {
                slope_start_key: round(x_start + stim_offset, precision),
                slope_end_key: round(x_end + stim_offset, precision),
                slope_width_key: round(slope_width, precision),
            }

        def handle_amp(aspect, x_start, stim_offset, precision):
            amp_key = f"t_{aspect}"
            return {
                "t_stim": stim_offset,
                amp_key: round(x_start + stim_offset, precision),
            }

        action = uistate.mouseover_action
        aspect = "_".join(action.split()[:2])
        stim_idx = uistate.list_idx_select_stims[0]
        prow = self.get_prow()
        n_stims = prow["stims"]
        dft_temp = uistate.dft_temp  # set when clicked
        stim_offset = dft_temp.at[stim_idx, "t_stim"]
        dffilter = None
        dict_t = None

        if uistate.checkBox["output_per_stim"]:
            x_axis = "stim"
            dfmean = self.get_dfmean(row=prow)
        else:
            x_axis = "sweep"
            dffilter = self.get_dffilter(row=prow)
            dfmean = None

        if aspect in ["EPSP_slope", "volley_slope"]:
            axis = uistate.ax2
            dict_t = handle_slope(aspect, x_start, x_end, precision, stim_offset)
        elif aspect in ["EPSP_amp", "volley_amp"]:
            axis = uistate.ax1
            dict_t = handle_amp(aspect, x_start, stim_offset, precision)

        for key, value in dict_t.items():
            dft_temp.at[stim_idx, key] = value
            if (
                not uistate.checkBox["timepoints_per_stim"] and n_stims > 1
            ):  # update all timepoints in df_t
                offset = dft_temp.at[stim_idx, "t_stim"] - dft_temp.at[stim_idx, key]
                for i, i_trow in dft_temp.iterrows():
                    dft_temp.at[i, key] = round(i_trow["t_stim"] - offset, precision)

        trow_temp = dft_temp.iloc[stim_idx]
        dict_t["t_EPSP_amp_halfwidth"] = trow_temp["t_EPSP_amp_halfwidth"]
        dict_t["t_volley_amp_halfwidth"] = trow_temp["t_volley_amp_halfwidth"]
        dict_t["norm_output_from"] = trow_temp["norm_output_from"]
        dict_t["norm_output_to"] = trow_temp["norm_output_to"]

        if x_axis == "stim":
            print("eventDragUpdate: dfstimoutput removed from last analysis.")
            # TODO: fix eventDragUpdate for dfstimoutput
            # out = analysis.build_dfstimoutput(dfmean=dfmean, dft=dft_temp)
        elif x_axis == "sweep":
            dict_t["stim"] = trow_temp["stim"]
            dict_t["amp_zero"] = trow_temp["amp_zero"]
            out = analysis.build_dfoutput(df=dffilter, dict_t=dict_t)

        # norm handling for EPSP
        if aspect in ["EPSP_amp", "EPSP_slope"]:
            aspect_norm = f"{aspect}_norm"
            outkey = aspect_norm if uistate.checkBox["norm_EPSP"] else aspect
            # print(f"eventDragUpdate - outkey {outkey}, {aspect}: t({trow_temp[f"t_{aspect}"]}) {out[aspect].iloc[0]}, {aspect_norm}: {out[aspect_norm].iloc[0]}")
        else:
            outkey = aspect
            # print(f"eventDragUpdate - outkey {outkey}, {aspect}: {out[aspect].iloc[0]}")

        if uistate.mouseover_out is None:
            uistate.mouseover_out = axis.plot(
                out[x_axis],
                out[outkey],
                color=uistate.settings[f"rgb_{aspect}"],
                linewidth=3,
            )
        else:
            uistate.mouseover_out[0].set_data(out[x_axis], out[outkey])

        self.canvasOutput.draw()

    def eventDragReleased(self, event, data_x, data_y):  # graph release event
        # TODO: Overhaul this whole magic-string-mess
        self.usage("eventDragReleased")
        print(f" - uistate.mouseover_action: {uistate.mouseover_action}")
        self.canvasEvent.mpl_disconnect(self.mouse_drag)
        self.canvasEvent.mpl_disconnect(self.mouse_release)
        uistate.x_drag_last = None
        if uistate.x_drag == uistate.x_on_click:  # nothing to update
            print("x_drag == x_on_click")
            self.mouseoverUpdate()
            return

        dft_temp = uistate.dft_temp  # copied on clicked, updated while dragging
        stim_idx = uistate.list_idx_select_stims[0]
        trow_temp = dft_temp.iloc[stim_idx]

        # Map drag actions to (0:method value, 1:aspect name, 2:{new measuring points}, 3:plot update function)
        action_mapping = {
            "EPSP slope": (
                "t_EPSP_slope_method",
                "EPSP slope",
                {
                    "t_EPSP_slope_start": trow_temp["t_EPSP_slope_start"],
                    "t_EPSP_slope_end": trow_temp["t_EPSP_slope_end"],
                },
                uistate.updateDragZones,
            ),
            "EPSP amp move": (
                "t_EPSP_amp_method",
                "EPSP amp",
                {
                    "t_EPSP_amp": trow_temp["t_EPSP_amp"],
                    "t_EPSP_amp_halfwidth": trow_temp["t_EPSP_amp_halfwidth"],
                    "amp_zero": trow_temp["amp_zero"],
                },
                uistate.updatePointDragZone,
            ),
            "volley slope": (
                "t_volley_slope_method",
                "volley slope",
                {
                    "t_volley_slope_start": trow_temp["t_volley_slope_start"],
                    "t_volley_slope_end": trow_temp["t_volley_slope_end"],
                },
                uistate.updateDragZones,
            ),
            "volley amp move": (
                "t_volley_amp_method",
                "volley amp",
                {
                    "t_volley_amp": trow_temp["t_volley_amp"],
                    "t_volley_amp_halfwidth": trow_temp["t_volley_amp_halfwidth"],
                    "amp_zero": trow_temp["amp_zero"],
                },
                uistate.updatePointDragZone,
            ),
        }
        # Build a dict_t of new measuring points and update drag zones
        for action, values in action_mapping.items():
            if uistate.mouseover_action.startswith(action):
                method_field = values[0]
                aspect = values[1]
                dict_t_updates = values[2]
                update_function = values[3]
                dict_t_updates[method_field] = "manual"
                dict_t_updates.update(
                    {
                        "stim": trow_temp["stim"],
                        "t_stim": trow_temp["t_stim"],
                        "norm_output_from": trow_temp["norm_output_from"],
                        "norm_output_to": trow_temp["norm_output_to"],
                    }
                )
                update_function()
                break

        # update selected row of dft_temp with the values from dict_t
        for key, value in dict_t_updates.items():
            dft_temp.loc[dft_temp.index[stim_idx], key] = value
            # old_trow = self.get_trow()
            # print(f" - * - stim{old_trow['stim']} {key} was {old_trow[key]}, set to {dft_temp.loc[dft_temp.index[stim_idx], key]}.")

        prow = self.get_prow()
        rec_name = prow["recording_name"]
        dfmean = self.get_dfmean(row=prow)

        # update dfoutput; dict and file, with normalized columns if applicable
        if False:  # uistate.checkBox['output_per_stim']:
            dfoutput = analysis.build_dfstimoutput(df=dfmean, df_t=dft_temp)
        else:
            dfoutput = self.get_dfoutput(row=prow)
            dffilter = self.get_dffilter(row=prow)
            stim_num = trow_temp["stim"]
            new_dfoutput = analysis.build_dfoutput(df=dffilter, dict_t=dict_t_updates)
            # print(f"dfoutput: {dfoutput}")
            # update volley means
            if aspect == "volley amp":
                dft_temp.loc[dft_temp.index[stim_idx], "volley_amp_mean"] = (
                    new_dfoutput["volley_amp"].mean()
                )
            elif aspect == "volley slope":
                dft_temp.loc[dft_temp.index[stim_idx], "volley_slope_mean"] = (
                    new_dfoutput["volley_slope"].mean()
                )

            new_dfoutput["stim"] = int(stim_num)
            for col in new_dfoutput.columns:
                dfoutput.loc[dfoutput["stim"] == stim_num, col] = new_dfoutput.loc[
                    new_dfoutput["stim"] == stim_num, col
                ]

        self.persistOutput(rec_name=rec_name, dfoutput=dfoutput)

        self.set_dft(rec_name, dft_temp)
        self.tableStimModel.setData(self.get_dft(prow))
        self.set_rec_status(rec_name=rec_name)
        trow = self.get_trow()
        uiplot.update(prow=prow, trow=trow, aspect=aspect, data_x=data_x, data_y=data_y)

        def update_amp_marker(trow, aspect, prow, dfmean, dfoutput):
            labelbase = f"{rec_name} - stim {trow['stim']}"
            labelamp = f"{labelbase} {aspect}"
            column_name = aspect.replace(" ", "_")
            t_aspect = f"t_{column_name}"
            stim_offset = trow["t_stim"]
            x = trow[t_aspect] - stim_offset
            y = dfmean.loc[dfmean["time"] == trow[t_aspect], prow["filter"]].values[0]
            amp = (
                dfoutput.loc[dfoutput["stim"] == trow["stim"]][column_name].mean()
                / 1000
            )  # conversion: mV to V
            t_amp = trow[t_aspect] - stim_offset
            amp_x = (
                t_amp - trow[f"{t_aspect}_halfwidth"],
                t_amp + trow[f"{t_aspect}_halfwidth"],
            )
            uiplot.updateAmpMarker(labelamp, x, y, amp_x, trow["amp_zero"], amp=amp)

        if aspect in ["EPSP amp", "volley amp"]:
            # print(f" - {aspect} updated")
            if False:  # uistate.checkBox['timepoints_per_stim']:
                update_amp_marker(trow, aspect, prow, dfmean, dfoutput)
            else:
                dft = self.get_dft(prow)
                for i, i_trow in dft.iterrows():
                    update_amp_marker(i_trow, aspect, prow, dfmean, dfoutput)

        # update groups
        affected_groups = self.get_groupsOfRec(prow["ID"])
        self.group_cache_purge(affected_groups)
        for group_ID in affected_groups:
            df_groupmean = self.get_dfgroupmean(group_ID)
            uiplot.addGroup(group_ID, self.dd_groups[group_ID], df_groupmean)
        self.mouseoverUpdate()

        if config.talkback:
            self.talkback()

    def zoomOnScroll(self, event, graph):
        if graph == "mean":
            canvas = self.canvasMean
            ax = uistate.axm
        elif graph == "event":
            canvas = self.canvasEvent
            ax = uistate.axe
        elif graph == "output":
            canvas = self.canvasOutput
            slope_left = uistate.slopeOnly()
            ax = uistate.ax2
            ax1 = uistate.ax1

        if event.button == "up":
            zoom = 1.1
        else:
            zoom = 1 / 1.1

        if (
            event.xdata is None or event.ydata is None
        ):  # if the scroll event was outside the axes, extrapolate x and y
            x_display, y_display = ax.transAxes.inverted().transform((event.x, event.y))
            x = x_display * (ax.get_xlim()[1] - ax.get_xlim()[0]) + ax.get_xlim()[0]
            y = y_display * (ax.get_ylim()[1] - ax.get_ylim()[0]) + ax.get_ylim()[0]
        else:
            x = event.xdata
            y = event.ydata

        left = 0.12 * (ax.get_xlim()[1] - ax.get_xlim()[0]) + ax.get_xlim()[0]
        right = 0.88 * (ax.get_xlim()[1] - ax.get_xlim()[0]) + ax.get_xlim()[0]
        bottom = 0.08 * (ax.get_ylim()[1] - ax.get_ylim()[0]) + ax.get_ylim()[0]
        on_x = y <= bottom
        on_left = x <= left
        on_right = x >= right

        # Apply the zoom
        ymin0 = uistate.checkBox["output_ymin0"]
        if on_x:  # check this first; x takes precedence
            ax.set_xlim(
                x - (x - ax.get_xlim()[0]) / zoom, x + (ax.get_xlim()[1] - x) / zoom
            )
        elif "slope_left" in locals():  # on output
            if on_left:
                if slope_left:  # scroll left y zoom output slope y
                    ymin = (
                        0 if ymin0 else y - (y - ax.get_ylim()[0]) / zoom
                    )  # TODO: uistate.checkBox...
                    ax.set_ylim(ymin, y + (ax.get_ylim()[1] - y) / zoom)
                else:  # scroll left y to zoom output amp y
                    ymin = (
                        0 if ymin0 else y - (y - ax1.get_ylim()[0]) / zoom
                    )  # TODO: uistate.checkBox...
                    ax1.set_ylim(ymin, y + (ax1.get_ylim()[1] - y) / zoom)
            elif on_right and not slope_left:  # scroll right y to zoom output slope y
                ymin = (
                    0 if ymin0 else y - (y - ax.get_ylim()[0]) / zoom
                )  # TODO: uistate.checkBox...
                ax.set_ylim(ymin, y + (ax.get_ylim()[1] - y) / zoom)
            else:  # default, scroll graph to zoom all
                ax1.set_xlim(
                    x - (x - ax1.get_xlim()[0]) / zoom,
                    x + (ax1.get_xlim()[1] - x) / zoom,
                )
                ymin = (
                    0 if ymin0 else y - (y - ax1.get_ylim()[0]) / zoom
                )  # TODO: uistate.checkBox...
                ax1.set_ylim(ymin, y + (ax1.get_ylim()[1] - y) / zoom)
                ymin = (
                    0 if ymin0 else y - (y - ax.get_ylim()[0]) / zoom
                )  # TODO: uistate.checkBox...
                ax.set_ylim(ymin, y + (ax.get_ylim()[1] - y) / zoom)
        else:  # on mean or event graphs
            if on_left:  # scroll left x to zoom mean or event x
                ax.set_ylim(
                    y - (y - ax.get_ylim()[0]) / zoom, y + (ax.get_ylim()[1] - y) / zoom
                )
            else:
                ax.set_xlim(
                    x - (x - ax.get_xlim()[0]) / zoom, x + (ax.get_xlim()[1] - x) / zoom
                )
                ax.set_ylim(
                    y - (y - ax.get_ylim()[0]) / zoom, y + (ax.get_ylim()[1] - y) / zoom
                )

        # TODO: this block is dev visualization for debugging
        if False:
            if hasattr(ax, "hline"):  # If the line exists, update it
                ax.hline.set_ydata(bottom)
            else:  # Otherwise, create a new line
                ax.hline = ax.axhline(y=bottom, color="r", linestyle="--")

        canvas.draw()

    # pyqtSlot decorators
    @QtCore.pyqtSlot()
    def slotAddDfData(self, df):
        self.addData(df)


# Root functions


def get_signals(source):
    cls = source if isinstance(source, type) else type(source)
    signal = type(QtCore.pyqtSignal())
    print("get_signals:")
    for subcls in cls.mro():
        clsname = f"{subcls.__module__}.{subcls.__name__}"
        for key, aspect in sorted(vars(subcls).items()):
            if isinstance(aspect, signal):
                print(f"{key} [{clsname}]")


# Mainguard
if __name__ == "__main__":
    print(f"\n\n{config.program_name} {config.version}\n")
    app = QtWidgets.QApplication(
        sys.argv
    )  # "QtWidgets.QApplication(sys.argv) appears to cause Qt: Session management error: None of the authentication protocols specified are supported"
    main_window = QtWidgets.QMainWindow()
    uisub = UIsub(main_window)
    main_window.show()
    sys.exit(app.exec_())
